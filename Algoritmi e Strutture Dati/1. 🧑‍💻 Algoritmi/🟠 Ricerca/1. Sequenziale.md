# Descrizione dell'Algoritmo üìÉ
Algoritmo per #ricercare in un array A di lunghezza $n$ un elemento $k$ e ritornare in che posizione si trova;
- Se non √® presente nell'array, ritornare $-1$.

# Pseudocodice üß¨
``` Pseudocodice TI:"Ricerca Sequenziale" "FOLD"
int Ricerca_Sequenziale(int[] A, int k)                      
	p = 1;
	while (p <= n) and (A[p] != k):
		p++
	if p <= n:
		return p
	else:
		return -1
```

# Complessit√† dell'algoritmo üî¨
- #### Tempi per Stringa
Line  | Istruzione                      | Comando | Costo Istruzione
----- | ------------------------------- | ------- | ----------------
2     | p = 1 | $c_1$ | 1
3     | while (p <= n) and (A[p] != k) | $c_2$ | $true_{while}$[+(1)](obsidian://open?vault=obsidian-git-sync&file=Algoritmi%20e%20Strutture%20Dati%2F0.%20%F0%9F%93%8C%20Formule%20e%20Convenzioni%2FCicli%20While) 
4     | p++ | $c_3$ | $true_{while}$
5     | if p <= n | $c_4$ | 1 
6     | return p | $c_5$ | $true_{if}$
7     | else | - | -
8     | return -1 | $c_6$ | $false_{if}$
*** 
- #### Tempo di Esecuzione ‚åõ
>$T(n)$ = $c_1$ + $c_2 ¬∑ (true_{while}+1)$ + $c_3 ¬∑ (true_{while})$ + $c_4$ + $c_5 ¬∑ (true_{if})$ + $c_6 ¬∑ (false_{if})$
***
- #### Caso Migliore üòÉ
>`k √® in prima posizione` $\Rightarrow$ $true_{while} = 0$, $true_{if} = 1$, $false_{if} = 0$
$T_{migliore}(n)$ = $c_1$ + $c_2$ + $c_4$ + $c_5$ ‚Åì $4c$ $\Rightarrow$ $Œ©(1)$

- #### Caso peggiore üò±
>`k ‚àâ A` $\Rightarrow$  $true_{while} = n$, $true_{if} = 0$, $false_{if} = 1$
$T_{peggiore}(n)$ = $c_1$ + $c_2 ¬∑ (n+1)$ + $c_3 ¬∑ n$ + $c_4$ + $c_5$ = 
= $2c ¬∑ n$ + $3c$ ‚Åì $2n$ $\Rightarrow$ $O(n)$

> [!summary]
> - ***Caso migliore:*** $Œ©(1)$
> - ***Caso peggiore***: $O(n)$

# Codice dell'Algoritmo üêç
```PYTHON TI:"Selection Sort" "FOLD"
def Ricerca_Sequenziale(A, k)
	n = len(A);                      
	p = 0;
	while (p < n) and (A[p] != k):
		p += 1
	if p < n:
		return p
	else:
		return -1
```
