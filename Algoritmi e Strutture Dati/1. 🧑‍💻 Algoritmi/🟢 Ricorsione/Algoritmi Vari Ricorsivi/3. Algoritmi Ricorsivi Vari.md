# Esercizio â›ï¸
Calcola MCD tra due numeri #ricorsivo:

``` Pseudocodice TI:"MCD" "FOLD"
int MCD(m, n) //m > 0, n > 0
	if n == 0: 
		return m
	if m == 0:
		return n
	else:
		if n > m:
			r = MCD(m, n-m)
		else:
			r = MCD(m-n, n)
		return r
```

# Esercizio â›ï¸
Ritorna il numero di $z$ in un array A #ricorsivo:

``` Pseudocodice TI:"TornaZ" "FOLD"
int TornaZ(A, i)
	if i > length(A):
		return 0
	else:
		if A[i] == 'z':
			return 1 + TornaZ(A, i+1)
		else
			return TornaZ(A, i+1)
```

# Esercizio â›ï¸
Algoritmo #ricorsivo che conta quanti elementi in un array A di interi sono seguiti dal suo successore:

``` Pseudocodice TI:"Conta_Successore" "FOLD"
int Conta_Successore(A, i)
	if i >= length(A):
		return 0
	else:
		if A[i] == A[i+1] - 1:
			return 1 + Conta_Successore(A, i+1)
		else
			return Conta_Successore(A, i+1)
	
```

# Esercizio â›ï¸
Somma gli elementi di un array #ricorsivamente ($1^o + ultimo + mezzo$):

``` Pseudocodice TI:"Somma_Array" "FOLD"
int Somma_Array(A, in, fin)
	if in > fin:
		return 0
	else if in == fin:
		return in
	else:
		return A[in] + A[fin] + Somma_Array(A, in + 1, fin - 1)
```

# Esercizio â›ï¸
Ritornare true se una parola Ã¨ palindroma #ricorsivamente, false se non lo Ã¨:

``` Pseudocodice TI:"Palindroma" "FOLD"
int Palindroma(A, in, fin)
	if in => fin:
		return true
	else:
		if A[in] == A[fin]:
			return Palindroma(A, in + 1, fin - 1)
		else:
			return false
```

- #### Caso Migliore ðŸ˜ƒ
>`prima e ultima lettera sono diverse`
$T_{migliore}(n) = 4c$

- #### Caso Peggiore ðŸ˜±
>`la parola Ã¨ palindroma`
$T_{peggiore}(n) = T(n-2) + 2c$