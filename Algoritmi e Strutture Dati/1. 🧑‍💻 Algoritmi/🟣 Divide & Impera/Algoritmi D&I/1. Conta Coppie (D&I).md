# Descrizione dell'Algoritmo ðŸ“ƒ
Algoritmo **D&I** che conta quante coppie di caratteri consecutivi uguali compaiono nell'array (es abbbcc -> bb - bb - cc):
- #Divide: $A$ viene diviso in due metÃ ;
- #Impera: contacoppie sx, contacoppie dx;
- #Combina: somma le quantitÃ  parziali;
# Pseudocodice ðŸ§¬
``` Pseudocodice TI:"Conta_Coppie" "FOLD"
int Conta_Coppie(A, In, Fine)
	if In >= Fine:
		return 0
	else:
		m = (In + Fine) / 2
		sx = Conta_Coppie(A, In, m)
		dx = Conta_Coppie(A, m+1, Fine)
		if A[m] == A[m+1]:
			return sx + dx + 1
		else:
			return sx + dx
```

# ComplessitÃ  dell'algoritmo ðŸ”¬
- #### Tempo di Esecuzione âŒ›
>$T(n) =
\begin {cases} 
2 && \text n â‰¤ 1 \\
2Â·T(\dfrac{n}{2}) + 3 && \text n > 1\\
\end {cases}
$ 
***
- #### Caso Migliore ðŸ˜ƒ
>`non ci sono coppie di caratteri` $\Rightarrow$ A = [a, b, c, d ,e, f, g, h]

- #### Caso Peggiore ðŸ˜±
>`sono tutte coppie` $\Rightarrow$ A = [a, a, a, a, a, a, a, a]

- # Metodo dell'Esperto ðŸ¤“
>$a = 2, b = 2$
$f(n) = 3$ $\longleftarrow$ minore
$n^{\log_b a} = n^{\log_2 2} = n$ $\longleftarrow$ maggiore
$3 = O(n^{1-Îµ})$, $Îµ>0$ ???
SÃ¬, $Îµ = \cfrac{1}{2}$ $\Rightarrow$ $3 = O(n^{\dfrac{1}{2}})$
$T(n) = Î¸(n)$