# Descrizione dell'Algoritmo ğŸ“ƒ
L' #algoritmo Radix Sort Ã¨ usato per ordinamenti su piÃ¹ chiavi diverse. 
Ad esempio: ordinare un insieme di studenti in base all'etÃ , a paritÃ  di etÃ  in base al cognome, a paritÃ  di cognome in base al nome.
- Controintuitivamente si procede in senso inverso: ordino rispetto al nome, quindi ordino rispetto al cognome e quindi rispetto all'etÃ ;
- Questo prevede che l'algoritmo di ordinamento usato ogni volta sia stabile;
***
Per fare ciÃ² avrÃ² bisogno di un indice $d$  che indicherÃ  quale chiave bisognerÃ  ordinare `(gestito nel ciclo for)`, partendo da quella di ordine piÃ¹ basso, a quella di ordine piÃ¹ alto.

# Pseudocodice ğŸ§¬
``` Pseudocodice TI:"Radix_Sort" "FOLD"
void Radix_Sort(A, d)	
	for i = d down to 1:
		usa un ordinamento stabile per ordinare A sulla cifra i
```

# ComplessitÃ  dell'algoritmo ğŸ”¬
- #### Tempo di Esecuzione âŒ›
>$T(n) \Rightarrow Î¸(dÂ·(x))$ $\longrightarrow$ dove $x$ Ã¨ il **tempo di esecuzione dell'algoritmo di ordinamento stabile usato** nel ciclo for per ogni chiave da ordinare.

>[!Note]
>Se dovessimo usare come algoritmo il **Merge Sort**, che come sappiamo Ã¨ stabile, allora il tempo totale del Radix Sort sarÃ :
>- $T(n) = Î¸(dÂ·(nÂ·\log n))$

# Simulazione dell'Algoritmo âš™ï¸
<center><img src="https://miro.medium.com/max/1400/1*iMJl98dVGwZBcmYh0Bh2eQ.png"></center>
