# Descrizione dell'Algoritmo üìÉ
L' #algoritmo di ordinamento Heap Sort utilizza le strutture dati **Array** e [**Heap**](obsidian://open?vault=obsidian-git-sync&file=Algoritmi%20e%20Strutture%20Dati%2F2.%20%F0%9F%94%A9%20Strutture%20Dati%2F%F0%9F%9F%A3%20Heap%2F1.%20Descrizione%20Heap).
L'insieme iniziale di numeri che vogliamo ordinare √® memorizzato in un array, e alla fine otterremo l'array ordinato.
- L'Heap Sort <mark style="background: #BBFABBA6;">funziona visualizzando gli elementi dell'array come uno heap</mark> .

# Pseudocodice üß¨
``` Pseudocodice TI:"Radix_Sort" "FOLD"
void Heap_Sort(A)
	BuildHeap(A)
	for i = 1 to n-1:
		scambia(V[1], V[A.heapsize])
		A.heapsize--
		Heapify(A, 1)
```

# Complessit√† dell'algoritmo üî¨
- #### Tempo di Esecuzione ‚åõ
	- La prima parte dell'algoritmo si occupa di eseguire un [**BuildHeap**](obsidian://open?vault=obsidian-git-sync&file=Algoritmi%20e%20Strutture%20Dati%2F2.%20%F0%9F%94%A9%20Strutture%20Dati%2F%F0%9F%9F%A3%20Heap%2F2.%20Operazioni%20Heap) sull'array dato come input $\Rightarrow O(n)$
	- Ora che si avr√† quindi uno Heap su cui lavorare si eseguir√† un intuitivo procedimento:
		- Scambio la radice $x$, cio√® l'elemento massimo dello heap in questo momento, con l'ultimo elemento dello heap, cos√¨ che ora avr√≤ $x$ ordinato nell'array;
		- Avendo ordinato l'elemento $x$ nell'array, non far√† pi√π parte dello heap, quindi decremento $A.heapsize$;
		- Ora per√≤ l'elemento alla radice distrugge le propriet√† dello heap, dunque viene eseguita una [**Heapify**](obsidian://open?vault=obsidian-git-sync&file=Algoritmi%20e%20Strutture%20Dati%2F2.%20%F0%9F%94%A9%20Strutture%20Dati%2F%F0%9F%9F%A3%20Heap%2F2.%20Operazioni%20Heap) sulla radice cos√¨ da ritornare ad avere uno heap;
		- Questo procedimento verr√† ripetuto per tutti gli $n-1$ elementi dell'array.
		>[!Note]
		>Viene ripetuto $n-1$ volte perch√® alla fine della $n-1-esima$ volta mi rimarr√† soltanto un elemento nello heap, che sar√† sicuramente ordinato nell'array.

# Simulazione dell'Algoritmo ‚öôÔ∏è
<center><img src="https://miro.medium.com/max/1047/0*hVi2iYTIVkrm9ODv.gif"></center>

Se devo "togliere" un elemento dalla **radice**, lo elimino e porto l'ultimo elemento alla radice e decremento $heapsize$, e faccio un Heapify dalla radice.