- ### Delete $k$
Dato uno stack $S$ e una chiave $k$, eliminare da $S$ tutte le occorrenze di $k$, usando come appoggio solo altri stack.
``` Pseudocodice TI:"Push" "FOLD"
void Stack_kDel(S, k)
	while not(Stackempty(S)):
		x = Pop(S)
		if x != k:
			Push(S_app, x)
	while not(Stackempty(S_app)):
		Push(S, Pop(S_app))
```

>$T(n)=3c·n + c·true_{if}+2c·true_{while}$
>- $T_{migliore}(n) = 3c·n \Rightarrow Ω(n) \rightarrow$ $S$ con tutti i valori $=k$
>- $T_{peggiore}(n) = 6c·n \Rightarrow O(n) \rightarrow$ $S$ non contiene valori $=k$
>- $T(n) \Rightarrow θ(n)$

- ### Due Stack in un Array
Realizzare due stack utilizzando solo un array. Non devo avere overflow. Non devo dire che è pieno se non ho più di N elementi in tutto.

>Diamo un'idea della soluzione:
>- uno stack punta all'inizio, una alla fine dell'array. Avrò un overflow quando i due indici si accavallano;
>- chiaramente sono da sistemare le operazioni per la pila che punta in fondo (e che deve quindi "crescere" al contrario);

- ### Trova $k$
Dato uno stack, stabilire se $k$ è presente nello stack.
``` Pseudocodice TI:"Push" "FOLD"
void Stack_kTrova(S, k)
	trovato = false:
	while not(Stackempty(S)) and not(trovato):
		x = Pop(S)
		if x == k:
			trovato = true
	return trovato
```

>- $T_{migliore}(1) \Rightarrow Ω(1) \rightarrow$ $k$ è in testa allo stack
>- $T_{peggiore}(n) \Rightarrow O(n) \rightarrow$ $S$ non contiene $k$

- ### Inverti Stringa
Dato uno stack $S$ contente una stringa, ribaltarla nello stesso stack $S$.

``` Pseudocodice TI:"Stack_Inverti_Stringa" "FOLD"
void Stack_Inverti_Stringa(S)
	while not(Stackempty(S)):
		x = Pop(S)
		Push(S1, x)
	while not(Stackempty(S1)):
		x = Pop(S1)
		Push(S2, x)
	while not(Stackempty(S2)):
		x = Pop(S2)
		Push(S, x)
```

>$T(n)=9c·n \Rightarrow θ(n)$ 

- ### Parentesi
Data una stringa contenuta in un array $A$ di caratteri, verificare che le parentesi siano annidate correttamente.

``` Pseudocodice TI:"checkParentesi" "FOLD"
boolean checkParentesi(A)
	i = 1
	ok = true
	while i <= len(A) && not(errore):
		if A[i] == '(' or A[i] == '[' or or A[i] == '{':
			Push(S, A[i])
		if A[i] == ')':
			if Stackempty(S) or Pop(S) != '(':
				ok = false
		if A[i] == ']':
			if Stackempty(S) or Pop(S) != '[':
				ok = false
		if A[i] == '}':
			if Stackempty(S) or Pop(S) != '{':
				ok = false
		i++
	if not(Stackempty(S)):
		ok = false
	return ok
```

>Il caso migliore si verifica quando il primo carattere è una parentesi chiusa di qualunque tipo. 
>
>Il caso peggiore è invece un'espressione (scritta bene o male) con più parentesi aperte che chiuse.

- ### Ordina Due Stack
Scrivere un algoritmo che dati in ingresso due stack $S1$ e $S2$ contententi ciascuna valori crescenti e uno stack vuoto $P$. Inserire in modo crescente gli elementi di $S1$ e $S2$ in $P$.

``` Pseudocodice TI:"Ordina_Stack" "FOLD"
void Ordina_Stack(S1, S2)
	// confronto 1 a 1 e metto quello più piccolo in S3
	while not(Stackempty(S1)) and not(Stackempty(S2)):
		if Top(S1) <= Top(S2):
			Push(S3, Pop(S1))
		else:
			Push(S3, Pop(S2))
			
	/*
	a questo punto uno dei due stack iniziali sarà vuoto, 
	lo svuoto in ordine in S3
	*/
	while not(Stackempty(S1)):
		Push(S3, Pop(S1))
	while not(Stackempty(S2)):
		Push(S3, Pop(S2))
		
	// ribalto
	while not(Stackempty(S3)):
		Push(P, Pop(S3))
```

>Sapendo che:
>- $true_{while^1}+true_{while^2}+true_{while^3}=n+m$
>- $true_{while^4}=n+m$
>- $T(n)$ ⁓ $3c·(n+m)+3c·(n+m) \Rightarrow θ(n+m)$

- ### Sequenza
Dato uno stack $S$ con lettere dell'alfabeto, dire se contiene una sequenza del tipo:
	- "$w$£$w^r$" 
	-dove $w$ è una parola, $w^r$ è la stessa parola però invertita e £ un simbolo

``` Pseudocodice TI:"isReverse" "FOLD"
boolean isReverse(S)
	// metto in P w
	while not(Stackempty(S)) and Top(S) != '£':
		Push(P, Pop(S))
	// se S è vuoto allora ritorno false
	if Stackempty(S):
		return false
	else:
		Pop(S)
		while not(Stackempty(P)) and nop(Stackempty(S)) 
			and Top(P) == Top(S):
				Pop(P)
				Pop(S)
		if Stackempty(P) and Stackempty(S):
			return true
		else:
			return false
```

>$T(n)=2c·true_{while^1}+2c·true_{if}+(3c·true_{while^2})·false_{if} + 2c$
>- $T_{migliore}(n)\Rightarrow Ω(1) \rightarrow$ il primo elemento di $S$ è il simbolo £
> - $T_{peggiore}(n) \Rightarrow O(n) \rightarrow$ quando si svuota $S$, quindi quando non è presente il carattere £ e lo stack si svuota nel primo while, oppure quando i caratteri di $w^r$  sono tutti uguali a tutti i primi caratteri di $w$, indipendentemente se si ritorna $true$ o $false$

- ### Sequenza Palindroma
Leggere caratteri da tastiera fino al carattere nullo. Dire se la sequenza inserita è palindroma utilizzando uno stack $S$. **Non è consentito contare i caratteri inseriti** (in tal caso l'esercizio è analogo al precedente).

``` Pseudocodice TI:"Stack_Palindromo" "FOLD"
boolean Stack_Palindromo()
	do 
		r = inuput(C)
		if r != ' ':
			Push(S1, r)
			Push(S2, r)
	while r != ' ' 
	//inverto S2
	while not(Stackempty(S2)):
		Push(S3, Pop(S2))
	//controllo che S1 e S2 siano identiche
	while not(Stackempty(S1)) and not(Stackempty(S3))
		and Top(S1) == Top(S3):
		Pop(S1)
		Pop(S3)
	if Stackempty(S1) and Stackempty(S3):
		return true
	else:
		return false
```

>$T(n)=5c·n+2n+3c·true_{while^2}+2c$
>- $T_{migliore}(n)\Rightarrow Ω(n) \rightarrow$ il primo e l'ultimo elemento sono diversi $(true_{while^2}=0)$
> - $T_{peggiore}(n) \Rightarrow O(n) \rightarrow$ la sequenza è palindroma $(true_{while^2}=1)$
> - $T(n) \Rightarrow θ(n)$
