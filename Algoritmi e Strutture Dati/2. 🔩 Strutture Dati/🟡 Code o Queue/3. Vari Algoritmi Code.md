- ### Coda con Stack
	Realizzare una coda utilizzando due stack $Q$ e $Qapp$.

``` Pseudocodice TI:"Enqueue" "FOLD"
void Enqueue(Q, x)
	Push(Q, x)
```

>$T(n)\Rightarrow θ(1)$ 

``` Pseudocodice TI:"Dequeue" "FOLD"
<type> Dequeue(Q)
	if StackEmpty(Q):
		error underflow
	else:
		while not(StackEmpty(Q)):
			Push(Qapp, Pop(Q))
		Pop(Qapp)
		while not(StackEmpty(Qapp)):
			Push(Q, Pop(Qapp))
```

>$T(n) = 2c·true_{if} + 2c·n·false_{if}$ 
>- $T_{migliore}(n) = 2c \Rightarrow Ω(1) \rightarrow$ Stack $Q$ vuoto
>- $T_{peggiore}(n) = 2c·n \Rightarrow O(n) \rightarrow$ Se $Q$ non è vuoto, si scorre per 2 volte il numero dei suoi elementi

``` Pseudocodice TI:"QueueEmpty" "FOLD"
boolean QueueEmpty(Q)
	if StackEmpty(Q):
		return true
	else:
		return false
```

>$T(n)\Rightarrow θ(1)$ 

Il problema di implementare una coda con degli stack sta nel fatto che la Dequeue avrà un tempo non costante, ma lineare.

- ### $k-esimo$ Elemento
Implementare una funzione che estragga il $k-esimo$ elemento della coda. Non è consentito l'uso di strutture dati diverse dalla coda. Se la coda contiene meno di $k$ elementi, errore di underflow.
Il contenuto di $Q$ deve essere lasciato inalterato.

- L'algoritmo funziona solo utilizzando un valore particolare che sappiamo che non può comparire nella lista (ad esempio -1 in una lista di interi positivi), che verrà aggiunto in coda per determinare la fine degli elementi su cui lavorare.

``` Pseudocodice TI:"Extract" "FOLD"
<type> Extract(Q, k)
	Enqueue(Q, -1)
	cont = k
	fine = false
	while cont > 1 and not(fine):
		x = Dequeue(Q)
		if x == -1:
			fine = true
		else:
			Enqueue(Q, x)
		cont--
	if fine == true:
		return -1
	else: 
		r = Dequeue(Q)
		x = r
		while x != -1:
			Enqueue(x)
			x = Dequeue(Q)
	return r
```
