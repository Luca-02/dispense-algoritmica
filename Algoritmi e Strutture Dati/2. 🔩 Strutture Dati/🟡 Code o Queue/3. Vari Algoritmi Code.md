- ### Coda con Stack
	Realizzare una coda utilizzando due stack $Q$ e $Qapp$.

``` Pseudocodice TI:"Enqueue" "FOLD"
void Enqueue(Q, x)
	Push(Q, x)
```

>$T(n)\Rightarrow θ(1)$ 

``` Pseudocodice TI:"Dequeue" "FOLD"
<type> Dequeue(Q)
	if StackEmpty(Q):
		error underflow
	else:
		while not(StackEmpty(Q)):
			Push(Qapp, Pop(Q))
		Pop(Qapp)
		while not(StackEmpty(Qapp)):
			Push(Q, Pop(Qapp))
```

>$T(n) = 2c·true_{if} + 2c·n·false_{if}$ 
>- $T_{migliore}(n) = 2c \Rightarrow Ω(1) \rightarrow$ Stack $Q$ vuoto
>- $T_{peggiore}(n) = 2c·n \Rightarrow O(n) \rightarrow$ Se $Q$ non è vuoto, si scorre per 2 volte il numero dei suoi elementi

``` Pseudocodice TI:"QueueEmpty" "FOLD"
boolean QueueEmpty(Q)
	if StackEmpty(Q):
		return true
	else:
		return false
```

>$T(n)\Rightarrow θ(1)$ 

Il problema di implementare una coda con degli stack sta nel fatto che la Dequeue avrà un tempo non costante, ma lineare.

- ### $k-esimo$ Elemento
	Implementare una funzione che estragga il $k-esimo$ elemento della coda. Non è consentito l'uso di strutture dati diverse dalla coda. Se la coda contiene meno di $k$ elementi, errore di underflow.
	Il contenuto di $Q$ deve essere lasciato inalterato.

	- L'algoritmo funziona solo utilizzando un valore particolare che sappiamo che non può comparire nella lista (ad esempio -1 in una lista di interi positivi), che verrà aggiunto in coda per determinare la fine degli elementi su cui lavorare.

``` Pseudocodice TI:"Extract" "FOLD"
<type> Extract(Q, k)
	Enqueue(Q, -1)
	i = k
	fine = false
	while i > 1 and not(fine):
		x = Dequeue(Q)
		if x = -1:
			fine = true
		else:
			Enqueue(Q, x)
		i--
	if fine true:
		errore overflow
	else:
		r = Dequeue(Q)
		x = Dequeue(Q)
		while x != -1:
			Enqueue(Q, x)
			x = Dequeue(Q)
		return r
```

>$T(n) = θ(n)$
>questo perchè tutti gli $n$ elementi della coda verrano utilizzati, sia se $k>n$ sia se $k≤n$.

- ### Delete $k$
	Scrivere una funzione che cancelli da una coda tutte le occorrenze di un valore $k$. Si possono usare come appoggio solo altre code.
	- Supponiamo di non poter usare un valore come -1, ovvero come fatto in precedenza.

``` Pseudocodice TI:"Del_k" "FOLD"
boolean Del_k(Q)
	while not(QueueEmpty(Q)):
		x = Dequeue(Q)
		if x != k
			Enqueue(Q1, x)
	while not(QueueEmpty(Q1)):
		x = Dequeue(Q1)
		Enqueue(Q, x)
```

>$T(n) = 3c·true_{while^1}+3c·true_{while^2}$
>- $T_{migliore}(n) = 3c·n \Rightarrow Ω(n) \rightarrow$ Ogni elemento di $Q$ è $=k$
>- $T_{peggiore}(n) = 3c·n+3c·n \Rightarrow O(n) \rightarrow$ $Q$ non contiene nessun elemento $=k$
>- $T(n)=θ(n)$

- ### Ordina code
	Data due code ordinate in ordine crescente lunghe $n$ e $m$, fonderle in una terza coda ordinata.

``` Pseudocodice TI:"Del_k" "FOLD"
<type> Del_k(Q1, Q2)
	if QueueEmpty(Q1):
		copia(Qf, Q2)
		return Qf
	if QueueEmpty(Q2):
		copia(Qf, Q1)
		return Qf
	x = Dequeue(Q1)
	y = Dequeue(Q2)
	while not(QueueEmpty(Q1)) and not(QueueEmpty(Q2)):
		if x <= y:
			Enqueue(Qf, x)
			Dequeue(Q1)
		else:
			Enqueue(Of, y)
			Dequeue(Q2)
	// ora una delle due code è vuota
	while not(QueueEmpty(Q1)):
		x = Dequeue(Q1)
		Enqueue(Qf, x)
	while not(QueueEmpty(Q1)):
		y = Dequeue(Q2)
		Enqueue(Qf, y)
	return Qf
```

>- $T_{migliore}(n) = 3c \Rightarrow Ω(1) \rightarrow$ Una delle due code è vuota
>- $T_{peggiore}(n) = 2c·n \Rightarrow O(n) \rightarrow$ Se $Q$ non è vuoto, si scorre per 2 volte il numero dei suoi elementi
