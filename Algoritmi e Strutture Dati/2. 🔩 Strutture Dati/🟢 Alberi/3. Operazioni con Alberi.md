>[!Important] 
>Il tempo di tutte le operazioni di un albero dipendono dalla sua altezza.
>- Se l'albero è ben bilanciato, tutte le operazioni richiedono tempo logaritmico.

- ### Ricerca in Albero Binario di Ricerca
Cercare un elemento k dato un albero binario di ricerca $T$.
``` Pseudocodice TI:"SBT_Search" "FOLD"
// chiamata: SBT_Search(T.root, k)
<type> SBT_Search(pT, k)
	if pT == Null:
		return Null
	else:
		if pT.key == k:
			return pT
		else:
			if pT.key > k:
				return SBT_Search(pT.left, k)
			else:
				return SBT_Search(pT.right, k)
```

>- $T_{migliore}(n) = 3c \Rightarrow Ω(1) \rightarrow$ $k=T.root$
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ $k\notin T$ e percorro il ramo più lungo (altezza dell'albero, quindi avrò un tempo di $O(\log n)$ nel caso $T$ sia ben bilanciato, e un tempo di $O(n)$ nel caso $T$ sia sbilanciato).

- ### Minimo/Massimo dell'Albero
	- Il **minimo** in un SBT (Serach Binary Tree), è l'elemento più a sinistra dell'albero che non ha figlio sinistro
	- Analogalmente, il **massimo** in un SBT (Serach Binary Tree), è l'elemento più a destra dell'albero che non ha figlio destro

``` Pseudocodice TI:"SBT_Min" "FOLD"
<type> SBT_Min(T)
	x = T.root
	if x != Null:
		while x.left != Null:
			x = x.left
	return x
```

>- $T_{migliore}(n) \Rightarrow Ω(1) \rightarrow$ $T.root.left=Null$ 
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ il minimo è il ramo più alto dell'albero 

``` Pseudocodice TI:"SBT_Max" "FOLD"
<type> SBT_Max(T)
	x = T.root
	if x != Null:
		while x.right != Null:
			x = x.right
	return x
```

>- $T_{migliore}(n) \Rightarrow Ω(1) \rightarrow$ $T.root.right=Null$ 
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ il massimo è il ramo più alto dell'albero

- ### Successore/Predecessore di $x$
	- Il **successore** di un nodo $x$ è il più piccolo tra tutti quelli più grandi di lui, quindi ho due casi:
		- o il successore è il minimo dell'albero $x.right$;
		- se $x.right = Null$ allora il suo successore lo troverò risalendo finchè non troverò un $p=p.parent.left$ o $p.parent=Null$, ovvero finchè risalendo verso l'alto non trovo una diramazione che va verso destra o nel caso non si trovi, $x$ non avrà un successore.
	- Analogalmente, il **predecessore** di un nodo $x$ è il più grande tra tutti quelli più piccoli di lui, quindi come prima avrò due casi:
		- o il predecessore è il massimo dell'albero $x.left$;
		- se $x.left = Null$ allora il suo predecessore lo troverò risalendo finchè non troverò un $p=p.parent.right$ o $p.parent=Null$, ovvero finchè risalendo verso l'alto non trovo una diramazione che va verso sinistra o nel caso non si trovi, $x$ non avrà un predecessore.
	

``` Pseudocodice TI:"SBT_Succ" "FOLD"
<type> SBT_Succ(x)
	if x.right != Null:
		return SBT_Min(x.right)
	else:
		Patt = x
		while Patt.parent != Null and Patt != Patt.parent.left:
			Patt = Patt.parent    //risalgo
		return Patt.parent
```

>- $T_{migliore}(n) \Rightarrow Ω(1) \rightarrow$ $x.right \not= Null$ 
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ $x$ è il massimo, e risalirò tutto l'albero fino alla radice 

``` Pseudocodice TI:"SBT_Pred" "FOLD"
<type> SBT_Pred(x)
	if x.right != Null:
		return SBT_Max(x.left)
	else:
		Patt = x
		while Patt.parent != Null and Patt != Patt.parent.right:
			Patt = Patt.parent    //risalgo
		return Patt.parent
```

>- $T_{migliore}(n) \Rightarrow Ω(1) \rightarrow$ $x.left \not= Null$ 
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ $x$ è il minimo, e risalirò tutto l'albero fino alla radice 

- ### Insert
##### Iterativo
Inserimento di un elemento $x$ in un albero di ricerca.
``` Pseudocodice TI:"SBT_Insert" "FOLD"
<type> SBT_Insert(T, x)
	if T.root == Null:
		T.root = x
	else:
		P = T.root
		Pa = Null
		while P != Null:
			Pa = P
			if x.key <= P.key
				P = P.left
			else:
				P = P.right
		if x.key <= P.key
			P.left = x
		else:
			P.right = x
```

>- $T_{migliore}(n) \Rightarrow Ω(1) \rightarrow$ $x$ viene inserito subito o a destra o a sinistra di $T.root$
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ dovrò scorrere il ramo più lungo dell'albero per inserire $x$

##### Ricorsivo
Inserimento di un elemento $x$ in un albero di ricerca ricorsivamente

``` Pseudocodice TI:"SBT_Insert_Recurvive" "FOLD"
// chiamata: SBT_Insert_Recurvive(T.root, x)
<type> SBT_Insert_Recurvive(pT, x)
	if x.key <= pT.key and pT.left == Null:
		pT.left = x
	if x.key > pT.key and pT.right == Null:
		pT.right = x
	else:
		if x.key <= pT.key:
			 SBT_Insert(pT.left, x)
		else:
			 SBT_Insert(pT.right, x)
```

>- $T_{migliore}(n) \Rightarrow Ω(1) \rightarrow$ $x$ viene inserito subito o a destra o a sinistra di $T.root$
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ dovrò scorrere il ramo più lungo dell'albero per inserire $x$