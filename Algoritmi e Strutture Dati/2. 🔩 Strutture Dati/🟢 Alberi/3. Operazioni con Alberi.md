>[!Important] 
>Il tempo di tutte le operazioni di un albero dipendono dalla sua altezza.
>- Se l'albero è ben bilanciato, tutte le operazioni richiedono tempo logaritmico.

- ### Ricerca in Albero Binario di Ricerca
Cercare un elemento k dato un albero binario di ricerca $T$.
``` Pseudocodice TI:"SBT_Search" "FOLD"
// chiamata: SBT_Search(T.root, k)
<type> SBT_Search(pT, k)
	if pT == Null:
		return Null
	else:
		if pT.key == k:
			return pT
		else:
			if pT.key > k:
				return SBT_Search(pT.left, k)
			else:
				return SBT_Search(pT.right, k)
```

>- $T_{migliore}(n) = 3c \Rightarrow Ω(1) \rightarrow$ $k=T.root$
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ $k\notin T$ e percorro il ramo più lungo (altezza dell'albero, quindi avrò un tempo di $O(\log n)$ nel caso $T$ sia ben bilanciato, e un tempo di $O(n)$ nel caso $T$ sia sbilanciato).

- ### Minimo/Massimo dell'Albero
>[!Note]
>- Il **minimo** in un SBT (Serach Binary Tree), è l'elemento più a sinistra dell'albero che non ha figlio sinistro
>- Analogalmente, il **massimo** in un SBT (Serach Binary Tree), è l'elemento più a destra dell'albero che non ha figlio destro
``` Pseudocodice TI:"SBT_Min" "FOLD"
<type> SBT_Min(T)
	x = T.root
	if x != Null:
		while x.left != Null:
			x = x.left
	return x
```

>- $T_{migliore}(n) \Rightarrow Ω(1) \rightarrow$ $T.root.left=Null$ 
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ il minimo è il ramo più alto dell'albero 

``` Pseudocodice TI:"SBT_Max" "FOLD"
<type> SBT_Max(T)
	x = T.root
	if x != Null:
		while x.right != Null:
			x = x.right
	return x
```

>- $T_{migliore}(n) \Rightarrow Ω(1) \rightarrow$ $T.root.right=Null$ 
>- $T_{peggiore}(n) \Rightarrow O(h) \rightarrow$ il massimo è il ramo più alto dell'albero

- ### Successore/Predecessore di $x$
	- Il successore di un nodo $x$ è il più piccolo tra tutti quelli più grandi di lui.
	- quindi ho due casi
