Uno degli usi degli Heap Ã¨ per implementare code di prioritÃ , oppure per l'algoritmo di ordinamento Heap Sort (descritto in [[8. Heap Sort]]).
***
# Descrizione della Struttura ðŸ“ƒ
Uno Heap Ã¨ un array $A$ che Ã¨ visto perÃ² come un albero binario quasi completo.
- <mark style="background: #BBFABBA6;">Ãˆ un albero binario completo</mark> a meno dell'ultimo livello, riempito comunque a partire da sinistra.
- Il nodo $i$, ha come figli i nodi $2i$ e $2i+1$ ($i$ Ã¨ l'indice dell'array).
	- es. 
		- dato un array: [1, 2, 3, 4, 5, 6, 7]
- $i.parent = int(\dfrac{i}{2})$
```mermaid
flowchart TB; 
i1((1))
i2((2))
i3((3))
i4((4))
i5((5))
i6((6))
i7((7))
i1 --2*1--> i2 
i1 --2*1+1--> i3
i2 --2*2--> i4
i2 --2*2+1--> i5
i3 --2*3--> i6
i3 --2*3+1--> i7
```
>[!Important] ProprietÃ 
>In uno heap i due figli di un nodo $i$ sono minori o uguali di $i$:
>- $\forall$ elemento $i$:
>	- $i.leftâ‰¤i$
>	- $i.rightâ‰¤i$
>
>- Possiamo dire con certezza che il primo elemento (**la radice**) Ã¨ il **massimo**.

- L'**altezza** di uno heap Ã¨ $Î¸(\log n)$;
- $length(A)$: lunghezza dell'array;
- $heapsize(A)$: quanti elementi dell'array formano lo heap;

>[!Note]
>- $0â‰¤heapsize(A)â‰¤length(A)$;
>- Heapsize Ã¨ dinamico e indica quanti elementi fanno parte dello heap;
>-  $heapsize$ varia in fase di esecuzione;

***

Le funzioni principali dello heap sono:
- **Heapify($A, i$)**
	- assume che $i.left$ e $i.right$ siano degli heap, ma $A[i]$ puÃ² essere piÃ¹ piccolo dei proprio figli.
	- Se questo Ã¨ il caso, la procedura fa scivolare lâ€™elemento $A[i]$ lungo un cammino dellâ€™albero in modo da ristabilire la proprietÃ  degli heap.


>### Esempio Grafico
><center><img src="https://cis.temple.edu/~pwang/5511-PT/Lecture/5511-04-03.jpg"></center>
>
> Questo grafico rappresenta la chiamata alla funzione Heapify$(A, 2)$:
> **a)** La configurazione iniziale con $A[2]$ nel nodo $i=2$ viola la proprietÃ  dello heap; 
> **b)** La proprietÃ  dello heap viene ripristinata nel nodo $2$ scambiandolo $A[2]$ con $A[4]$, ma questo distrugge la proprietÃ  la proprietÃ  dello heap nel nodo $4$.
> La chiamata ricorsiva Heapify$(A, 4)$ adesso ha $i=4$.
> Dopo aver scambiato $A[4]$ con $A[9]$ 


- **BuildHeap($A$)**:
	- Da un array disordinato ottengo uno heap;