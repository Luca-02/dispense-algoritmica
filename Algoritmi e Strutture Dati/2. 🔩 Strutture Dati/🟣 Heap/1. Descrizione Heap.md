Uno degli usi degli Heap √® per implementare code di priorit√†, oppure per l'algoritmo di ordinamento Heap Sort (descritto in [[8. Heap Sort]]).
***
# Descrizione della Struttura üìÉ
Uno Heap √® un array $A$ che √® visto per√≤ come un albero binario quasi completo.
- <mark style="background: #BBFABBA6;">√à un albero binario completo</mark> a meno dell'ultimo livello, riempito comunque a partire da sinistra.
- Il nodo $i$, ha come figli i nodi $2i$ e $2i+1$ ($i$ √® l'indice dell'array).
	- es. 
		- dato un array: [1, 2, 3, 4, 5, 6, 7]
- $i.parent = int(\dfrac{i}{2})$
```mermaid
flowchart TB; 
i1((1))
i2((2))
i3((3))
i4((4))
i5((5))
i6((6))
i7((7))
i1 --2*1--> i2 
i1 --2*1+1--> i3
i2 --2*2--> i4
i2 --2*2+1--> i5
i3 --2*3--> i6
i3 --2*3+1--> i7
```
>[!Important] Propriet√†
>In uno heap i due figli di un nodo $i$ sono minori o uguali di $i$:
>- $\forall$ elemento $i$:
>	- $i.left‚â§i$
>	- $i.right‚â§i$
>
>- Possiamo dire con certezza che il primo elemento (**la radice**) √® il **massimo**.

- L'**altezza** di uno heap √® $Œ∏(\log n)$;
- $A.length$: lunghezza dell'array;
- $A.heapsize$: quanti elementi dell'array formano lo heap;

>[!Note]
>- $0‚â§heapsize(A)‚â§length(A)$;
>- Heapsize √® dinamico e indica quanti elementi fanno parte dello heap;
>-  $heapsize$ varia in fase di esecuzione;

***

Le funzioni principali dello heap sono:
- **Heapify($A, i$)**
	- assume che $i.left$ e $i.right$ siano degli heap, ma $A[i]$ pu√≤ essere pi√π piccolo dei proprio figli.
	- Se questo √® il caso, la procedura fa scivolare l‚Äôelemento $A[i]$ lungo un cammino dell‚Äôalbero in modo da ristabilire la propriet√† degli heap.
<br>
>### Esempio Grafico
><center><img src="https://cis.temple.edu/~pwang/5511-PT/Lecture/5511-04-03.jpg"></center>
>
> Questo grafico rappresenta la chiamata alla funzione Heapify$(A, 2)$:
> **a)** La configurazione iniziale con $A[2]$ nel nodo $i=2$ viola la propriet√† dello heap; 
> **b)** La propriet√† dello heap viene ripristinata nel nodo $2$ scambiandolo $A[2]$ con $A[4]$, ma questo distrugge la propriet√† la propriet√† dello heap nel nodo $4$. La chiamata ricorsiva Heapify$(A, 4)$ adesso ha $i=4$.
> **c)** Dopo aver scambiato $A[4]$ con $A[9]$ il nodo $4$ √® sistemato e la chiamata ricorsiva Heapify$(A, 9)$ non apporter√† ulteriori modifiche.
<br>
- **BuildHeap($A$)**:
	- Da un array disordinato ottengo uno heap;