- ### Heapify($A, i$)
	- assume che $i.left$ e $i.right$ siano degli heap, ma $A[i]$ può essere più piccolo dei proprio figli.
	- Se questo è il caso, la procedura fa scivolare l’elemento $A[i]$ lungo un cammino dell’albero in modo da ristabilire la proprietà degli heap.

``` Pseudocodice TI:"Heapify" "FOLD"
void Heapify(A, i)
	l = i * 2
	r = (i * 2) + 1
	max = i
	if l <= A.heapsize and A[l] > A[max]:
		max = l
	if r <= A.heapsize and A[r] > A[max]:
		max = r
	if max != i:
		temp = A[i]
		A[i] = A[max]
		A[max] = temp
		Heapify(A, max)
``` 

>Il tempo 
>- $T_{migliore}(n) = 3c + 2c + 1c \Rightarrow Ω(1) \rightarrow$ $max$ rimane $i$ oppure $i$ non ha figli
>- $T_{peggiore}(n) = 6c·n \Rightarrow O(\log n) \rightarrow$   

<br>

>### Esempio Grafico
><center><img src="https://cis.temple.edu/~pwang/5511-PT/Lecture/5511-04-03.jpg"></center>
>
> Questo grafico rappresenta la chiamata alla funzione Heapify$(A, 2)$:
> **a)** La configurazione iniziale con $A[2]$ nel nodo $i=2$ viola la proprietà dello heap; 
> **b)** La proprietà dello heap viene ripristinata nel nodo $2$ scambiandolo $A[2]$ con $A[4]$, ma questo distrugge la proprietà la proprietà dello heap nel nodo $4$. La chiamata ricorsiva Heapify$(A, 4)$ adesso ha $i=4$.
> **c)** Dopo aver scambiato $A[4]$ con $A[9]$ il nodo $4$ è sistemato e la chiamata ricorsiva Heapify$(A, 9)$ non apporterà ulteriori modifiche.