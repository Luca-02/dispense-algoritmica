# Descrizione dell'Algoritmo ðŸ“ƒ
Dati $A$ e $B$ due array di lunghezza $n$, dire `quanti` elementi di $A$ compaiono in $B$.

# Pseudocodice ðŸ§¬
``` Pseudocodice TI:"Ricerca_Elementi" "FOLD"
int Ricerca_Elementi(A[], B[])
	count = 0
	for i = 1 to length(B):
		j = 1
		while j <= length(A) and B[i] != A[j]:
			j++
		if j <= n
			count++
	return count
```

# ComplessitÃ  dell'algoritmo ðŸ”¬
- #### Tempi per Stringa
Line | Istruzione | Comando | Costo Istruzione
----- | ----- | ----- | -----
2 | count = 0 | $c_1$| $1$
3 | for i = 1 to length(B) | $c_2$| $n$
4 | j = 1 | $c_3$| $n$ 
5 | while j <= length(A) and B[i] != A[j] |$c_4$ | $\sum\limits_{i = 1}^{n} {true_{while_i}}$
6 | j++ |$c_5$ | $\sum\limits_{i = 1}^{n} {true_{while_i}}$
7 | if j <= n |$c_6$ | $n$
8 | count++ |$c_7$ | $true_{if}$
9 | return count |$c_8$| $1$
***
- #### Tempo di Esecuzione âŒ›
>$T(n)$ = $2c + 3c Â· n + 2c Â· (\sum\limits_{i = 1}^{n} 
{true_{while_i}}) + c Â· true_{if}$
***
- #### Caso Migliore ðŸ˜ƒ
>`B contiene un solo numero ripetuto n volte ed Ã¨ uguale al primo elemento di A` $\Rightarrow$ ${true_{while_i}} = 0$, $true_{if} = n$
$T_{migliore}(n)$ = $2c + 4c Â· n$ â“ $n$ $\Rightarrow$ $Î©(n)$

- #### Caso Peggiore ðŸ˜±
>`Nessun elemento di B compare in A` $\Rightarrow$ ${true_{while_i}} = n$ $âˆ€i$, $true_{if} = 0$
$T_{peggiore}(n)$ = $2c + 3c Â· n + 2c Â· (\sum\limits_{i = 1}^{n} 
n)$ = 
= $2c + 3c Â· n + 2c Â· n^2$ â“ $n^2$ $\Rightarrow$ $O(n^2)$

> [!Summary]
> - ***Caso migliore:*** $Î©(n)$
> - ***Caso peggiore***: $O(n^2)$