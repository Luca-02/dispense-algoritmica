# Descrizione dell'Algoritmo ðŸ“ƒ
Algoritmo per la ricerca dicotomica **D&I** in un array $A$ un elemento $k$:
- #Divide: $A$ viene diviso in due metÃ ;
- #Impera: cerca $k$ a sx, cerca $k$ a dx;
- #Combina: fondo i risultati;
# Pseudocodice ðŸ§¬
``` Pseudocodice TI:"Dsearch" "FOLD"
int Dsearch(A, k, In, Fine)
	if In == Fine:
		if A[In] == k:
			return In
		else:
			return -1
	else:
		m = (In + Fine) / 2
		if A[m] == k:
			return m
		else:
			if A[m] > k:
				return Dsearch(A, k, In, m)
			else:
				return Dsearch(A, k, m+1, Fine)
```

# ComplessitÃ  dell'algoritmo ðŸ”¬
- #### Tempo di Esecuzione âŒ›
>$T(n) =
\begin {cases} 
3 && \text n â‰¤ 1 \\
2Â·T(\dfrac{n}{2}) + 4 && \text n > 1\\
\end {cases}
$ 
***
- #### Caso Migliore ðŸ˜ƒ
>`k Ã¨ nella posizione m`  $\Rightarrow$ $k = A[\dfrac{len(A)}{2}]$ $\Rightarrow$ $Î©(1)$
$T{migliore}(n) =
\begin {cases} 
3 && \text n â‰¤ 1 \\
4 && \text n > 1\\
\end {cases}
$ 
- #### Caso Peggiore ðŸ˜±
>`k non Ã¨ in A` $\Rightarrow$ $O(\log n)$
$T{peggiore}(n) =
\begin {cases} 
3 && \text n â‰¤ 1 \\
2Â·T(\dfrac{n}{2}) + 4 && \text n > 1\\
\end {cases}
$ 

> [!Summary]
> - ***Caso migliore:*** $Î©(1)$
> k = A[m]
> - ***Caso peggiore***: $O(\log n)$
>k âˆ‰ A