# Descrizione dell'Algoritmo üìÉ
L' #algoritmo di ordinamento Quick Sort #randomizzato √® una versione diciamo 2.0 del [[5. Quick Sort (D&I)]].
**L'unico cambiamento** dal Quick Sort normale √® quello di scegliere il pivot a random al posto di prendere sempre una posizione fissa.
- Poich√® il pivot sar√† scelto a caso, ci si aspetta che la `ripartizione` dell'array sar√† `mediamente pi√π bilanciata`, e che quindi il tempo di esecuzione medio sar√† ancora pi√π vicino a $Œ∏(n\log n)$ al posto di $Œ∏(n^2)$ avendo un bilanciamento mediamente migliore;
# Pseudocodice üß¨
In termini di codice l'unico <mark style="background: #BBFABBA6;">cambiamento effettivo si avr√† nel momento in cui si andr√† ad inizializzare il pivot</mark> , quindi prima di chiamare la funzione **Partition_X** di Lomuto o Hoare, si andr√† a chiamare una nuova mini-funzione che scambi la posizione dove si andr√† a prendere il pivot (con Lomuto sar√† $Fine$, con Hoare $In$) 
con una posizione casuale dell'*array*:

``` Pseudocodice TI:"Randomized_Partition_Lomuto" "FOLD"
void Randomized_Partition_Lomuto(A[], In, Fine)
	rand = Random(In, Fine)
	swap A[rand] with A[Fine]
	return Partition_Lomuto(A, In, Fine)
```

``` Pseudocodice TI:"Randomized_Partition_Hoare" "FOLD"
void Randomized_Partition_Hoare(A[], In, Fine)
	rand = Random(In, Fine)
	swap A[rand] with A[In]
	return Partition_Hoare(A, In, Fine)
```
