# Descrizione dell'Algoritmo ğŸ“ƒ
L' #algoritmo di ordinamento Heap Sort utilizza le strutture dati **Array** e [**Heap**](obsidian://open?vault=obsidian-git-sync&file=Algoritmi%20e%20Strutture%20Dati%2F2.%20%F0%9F%94%A9%20Strutture%20Dati%2F%F0%9F%9F%A3%20Heap%2F1.%20Descrizione%20Heap).
L'insieme iniziale di numeri che vogliamo ordinare Ã¨ memorizzato in un array, e alla fine otterremo l'array ordinato.
- L'Heap Sort <mark style="background: #BBFABBA6;">funziona visualizzando gli elementi dell'array come uno heap</mark> .

>[!Note]
>- **NON STABILE**: i valori uguali **NON** mantengono l'ordine iniziale prestabilito perchÃ© non so cosa "succede" agli elementi;
>- **IN LOCO**: non ho bisogno di alcune variabili di appoggio (*array*) al variare dell'input;

***
- La prima parte dell'algoritmo si occupa di eseguire un [**BuildHeap**](obsidian://open?vault=obsidian-git-sync&file=Algoritmi%20e%20Strutture%20Dati%2F2.%20%F0%9F%94%A9%20Strutture%20Dati%2F%F0%9F%9F%A3%20Heap%2F2.%20Operazioni%20Heap) sull'array dato come input $\Rightarrow O(n)$
- Ora che si avrÃ  quindi uno Heap su cui lavorare si eseguirÃ  un intuitivo procedimento:
	- Scambio la radice $x$, cioÃ¨ l'elemento massimo dello heap in questo momento, con l'ultimo elemento dello heap, cosÃ¬ che ora avrÃ² $x$ ordinato nell'array;
	- Avendo ordinato l'elemento $x$ nell'array, non farÃ  piÃ¹ parte dello heap, quindi decremento $A.heapsize$;
	- Ora perÃ² l'elemento alla radice distrugge le proprietÃ  dello heap, dunque viene eseguita una [**Heapify**](obsidian://open?vault=obsidian-git-sync&file=Algoritmi%20e%20Strutture%20Dati%2F2.%20%F0%9F%94%A9%20Strutture%20Dati%2F%F0%9F%9F%A3%20Heap%2F2.%20Operazioni%20Heap) sulla radice cosÃ¬ da ritornare ad avere uno heap;
	- Questo procedimento verrÃ  ripetuto per tutti gli $n-1$ elementi dell'array.

>[!Note]
>Viene ripetuto $n-1$ volte perchÃ¨ alla fine della $n-1-esima$ volta mi rimarrÃ  soltanto un elemento nello heap, che sarÃ  sicuramente ordinato nell'array.
# Pseudocodice ğŸ§¬
``` Pseudocodice TI:"Heap_Sort" "FOLD"
void Heap_Sort(A)
	BuildHeap(A)
	for i = 1 to n-1:
		scambia(A[1], A[A.heapsize])
		A.heapsize--
		Heapify(A, 1)
```

# ComplessitÃ  dell'algoritmo ğŸ”¬
- #### Tempo di Esecuzione âŒ›
	- La **BuildHeap** avrÃ  un tempo di $O(n)$;
	- La **Heapify** sarÃ  sempre chiamata dalla radice, e quindi lontana dalle foglie, dunque il suo tempo di esecuzione sarÃ  quasi sempre $O(\log n)$, moltiplicata per $n-1$ volte;

Giungo a una conclusione:
>$T(n) = O(n) + (n-1)Â·O(\log n) \Rightarrow T(n) = O(nÂ·\log n)$ 

# Simulazione dell'Algoritmo âš™ï¸
<center><img src="https://miro.medium.com/max/1047/0*hVi2iYTIVkrm9ODv.gif"></center>

Se devo "togliere" un elemento dalla **radice**, lo elimino e porto l'ultimo elemento alla radice e decremento $heapsize$, e faccio un Heapify dalla radice.