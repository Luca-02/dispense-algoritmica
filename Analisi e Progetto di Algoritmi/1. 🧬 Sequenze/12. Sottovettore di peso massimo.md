>[!Premise]
>Dato un vettore $V = (v_1, v_2, . . . , v_n)$ si definisce un sottovettore qualunque di $V$ un vettore $(v_h, v_{h+1}, . . . , v_k)$ con $1 ≤ h ≤ k ≤ n$. Inoltre, si definisce il peso di un sottovettore come la somma dei suoi elementi, ossia $w(v_h, . . . , v_k) = \sum^{k}\limits_{r=h} v_k$. 
>Infine, si definisce l’insieme di tutti i possibili sottovettori di $V$ come $sub\_vec(V) = {(v_h, . . . , v_k) | 1 ≤ h ≤ k ≤ n}$.

*Dato un vettore $V ∈ Z^n$ determinare il peso $w$ di un sottovettore $S$ di $V$ tale che: $$w(S) = max_{A∈sub\_vec(V)}\{w(A)\}$$*

--- 
## Sottoproblemi

*Dato un vettore $V ∈ Z^n$ determinare il peso di un sottovettore $S$ di un suo prefisso $V_i$ tale che: $$w(S) = max_{A∈sub\_vec(V_i)}\{w(A)\}$$
- Considerato il sottoproblema di dimensione $(i)$, la `variabile` ad esso associata è $w_i$ ed è così definita:
	- $w_i$ = peso di uno dei sottovettori di **peso massimo** del prefisso $V_i$ di $V$

**Numero di sottoproblemi**: $n+1$

Purtroppo, però, il problema così definito **non è risolvibile**! `Ci manca informazione`.
Non c’è alcun modo per poter comprendere se l’elemento $v_i$ possa essere accodato ad un sottovettore che è soluzione di uno dei sottoproblemi di dimensione minore a $i$, assicurando che cio’ che si ottiene sia ancora un sottovettore di $V_i$ (e ciò sarebbe garantito se si accodasse $v_i$ ad un sottovettore soluzione di un sottoproblema che termini esattamente con $v_{i−1}$).

Risulta necessario **introdurre un problema ausiliario**, nel quale introdurre l’informazione mancante necessaria.

---
## Problema ausiliario (sottoproblema vincolato)

*Dato un vettore $V ∈ Z^n$ determinare il peso di un sottovettore $S$ di un suo prefisso $V_i$ tale che: $$w(S) = max_{A∈sub\_vec(V_i)}\{w(A)\}$$e che termina con $v_i$.

- Considerato il sottoproblema di dimensione $(i)$, la `variabile` ad esso associata è $w_i$ ed è così definita:
	- $w_i$ = peso di uno dei sottovettori di **peso massimo** del prefisso $V_i$ di $V$ e che termina con $v_i$

**Numero di sottoproblemi**: $n+1$
**Soluzione del problema**: $max({w_i | 1 \leq i \leq n})$

---
## Equazioni di ricorrenza

#### <u>**Caso base**</u>: $i = 1$
- Il caso base si ha per un qualunque sottoproblema di dimensione $(i)$ con $i = 1$, ossia quando il prefisso **comprende solamente il primo elemento**. In questo caso, visto che per definizione del problema ausiliaro, l’elemento vi appartiene sempre alla soluzione:
$$w_1 = v_1$$

#### <u>**Passo ricorsivo**</u>: $i > 1$
- Come è possibile ottenere la soluzione $w_i$ andando a combinare le soluzioni dei sottoproblemi di dimensione minore a $(i)$ ed, eventualmente, accodando l’elemento vi estratto dall’input $Vi$?
	- `caso 1`: il sottovettore di peso massimo del prefisso $V_i$ **contiene esclusivamente l’elemento** $v_i$ . In questo caso allora la soluzione sarà $$w_i = v_i$$
	- `caso 2`: il sottovettore di peso massimo del prefisso $V_i$ si ottiene **concatenando l’elemento** $v_i$ alla soluzione ottenuta dal sottoproblema di dimensione $(i − 1)$. In questo caso allora la soluzione sarà $$w_i = v_i + w_{i−1}$$
- Dato che non sappiamo quale dei due casi si verifichi, è necessario considerare entrambi e scegliere la soluzione di valore massimo, quindi: $$wi = max(v_i , v_i + w_{i−1})$$

---
## Algoritmo DP

1. uso una **matrice** $OPT[0...n][0...C]$ per salvare tutti i `sottoproblemi` $OPT_{i, c}$
2. uso una **matrice** $S[0...n][0...C]$ per salvare i sottoinsiemi finali di ogni sottoproblema 

``` Pseudocodice TI:"KP" "FOLD"
void KP(n, C)
	for i from 0 to n do 
		OPT[i, 0] = 0
		S[i, 0] = ∅
	for c from 0 to C do
		OPT[0, c] = 0
		S[0, c] = ∅
	for i from 1 to n do 
		for c from 1 to C do 
			if w[i] > c then 
				OPT[i, c] = OPT[i-1, c]
				S[i, c] = S[i-1, c]
			else
				V1 = OPT[i-1, c]
				V2 = OPT[i−1, c−w[i]] + v[i]
				OPT[i, c] = MAX(V1, V2)
				if V1 > V2 then
					S[i, c] = S[i-1, c]
				else
					S[i, c] = S[i-1, c-w[i]] ∪ i
	return (OPT[n, C], S[n, C])
```


> [!Summary]
> - ***Complessità***: $O(nC)$
> - ***Memoria***: $O(nC + n^2C)$

![[Pasted image 20231115223635.png]]

---

## Ricostruzione delle operazioni

- se non dovessi usare la matrice $S[0...n][0...C]$

``` Pseudocodice TI:"ricostruisci_KP" "FOLD"
void ricostruisci_KP(OPT, i, c)
	if i > 0 and c > o then
		if w[i] > c then
			ricostruisci_KP(OPT, i-1, c)
		else
			if OPT[i, c] == OPT[i-1, c] then
				ricostruisci_KP(OPT, i-1, c)
			else
				ricostruisci_KP(OPT, i-1, c-w[i])
				print i
``` 

![[Pasted image 20231020173943.png]]