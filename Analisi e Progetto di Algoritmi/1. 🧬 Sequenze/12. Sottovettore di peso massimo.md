>[!Premise]
>Dato un vettore $V = (v_1, v_2, . . . , v_n)$ si definisce un sottovettore qualunque di $V$ un vettore $(v_h, v_{h+1}, . . . , v_k)$ con $1 ≤ h ≤ k ≤ n$. Inoltre, si definisce il peso di un sottovettore come la somma dei suoi elementi, ossia $w(v_h, . . . , v_k) = \sum^{k}\limits_{r=h} v_k$. 
>Infine, si definisce l’insieme di tutti i possibili sottovettori di $V$ come $sub\_vec(V) = {(v_h, . . . , v_k) | 1 ≤ h ≤ k ≤ n}$.

*Dato un vettore $V ∈ Z^n$ determinare il peso $w$ di un sottovettore $S$ di $V$ tale che: $$w(S) = max_{A∈sub\_vec(V)}\{w(A)\}$$*

--- 
## Sottoproblemi

*Dato un vettore $V ∈ Z^n$ determinare il peso di un sottovettore $S$ di un suo prefisso $V_i$ tale che: $$w(S) = max_{A∈sub\_vec(V_i)}\{w(A)\}$$
- Considerato il sottoproblema di dimensione $(i)$, la `variabile` ad esso associata è $w_i$ ed è così definita:
	- $w_i$ = peso di uno dei sottovettori di **peso massimo** del prefisso $V_i$ di $V$

**Numero di sottoproblemi**: $n+1$

Purtroppo, però, il problema così definito **non è risolvibile**! `Ci manca informazione`.
Non c’è alcun modo per poter comprendere se l’elemento $v_i$ possa essere accodato ad un sottovettore che è soluzione di uno dei sottoproblemi di dimensione minore a $i$, assicurando che cio’ che si ottiene sia ancora un sottovettore di $V_i$.

Risulta necessario **introdurre un problema ausiliario**, nel quale introdurre l’informazione mancante necessaria.

---
## Problema ausiliario (sottoproblema vincolato)

*Dato un vettore $V ∈ Z^n$ determinare il peso di un sottovettore $S$ di un suo prefisso $V_i$ tale che: $$w(S) = max_{A∈sub\_vec(V_i)}\{w(A)\}$$e che termina con $v_i$.

- Considerato il sottoproblema di dimensione $(i)$, la `variabile` ad esso associata è $w_i$ ed è così definita:
	- $w_i$ = peso di uno dei sottovettori di **peso massimo** del prefisso $V_i$ di $V$ e che termina con $v_i$

**Numero di sottoproblemi**: $n+1$
**Soluzione del problema**: $max({w_i | 1 \leq i \leq n})$

---
## Equazioni di ricorrenza

#### <u>**Caso base**</u>: $i = 0 ∨ c = 0$
- In questo caso, è facile ottenere la soluzione del sottoproblema. Infatti, se $i = 0$, `non abbiamo oggetti` mentre se $c = 0$ si richiede che l’insieme di oggetti abbia **ingombro complessivo pari a 0**:
$$OPT_{i, c} = 0 \text{ e } S_{i, c} = ∅ \quad\text{se } i = 0 ∨ c = 0$$

#### <u>**Passo ricorsivo**</u>: $i > 0 ∧ c > 0$
1. $w_i > c$ : 
	se l’oggetto ha **ingombro maggiore della capacità**, allora l’oggetto `non può appartenere alla soluzione` e quindi si va a considerare la soluzione del sottoproblema di dimensione minore $(i−1, c)$:
	$$OPT_{i, c} = OPT_{i-1, c} \text{ e } S_{i, c} = S_{i-1, c} \quad\text{se } w_i > c$$

2. $w_i ≤ c$: se l’oggetto ha **ingombro minore o uguale della capacità**, allora l’oggetto `potrebbe appartenere alla soluzione`. Ci si può quindi trovare in due sottocasi:
	- $i \not\in S_i$ : se l’oggetto i **non appartiene alla soluzione**, allora è sufficiente considerare l’insieme di oggetti $\{1, . . . , i − 1\}$ e si può dunque considerare la soluzione del sottoproblema di dimensione $(i−1, c)$, ossia: $$OPT_{i, c} = OPT_{i-1, c} \text{ e } S_{i, c} = S_{i-1, c}$$
	- $i ∈ S_i$ : se l’oggetto i **appartiene alla soluzione**, allora è necessario andare a determinare la soluzione del sottoproblema di dimensione minore a $(i, c)$ di valore massimo e il cui insieme di oggetti risulta essere compatibile con l’oggetto $i$: ossia è possibile aggiungere l’oggetto $i$ senza superare la capacità $c$. E dunque possibile considerare la soluzione del sottoproblema di dimensione $(i − 1, c − w_i)$ e aggiungere a questo l’oggetto $i$ `(si noti come alla capacità sia stato tolto il peso dell’oggetto che si vuole aggiungere)`: $$OPT_{i, c} = OPT_{i-1, c-w_i}+v_i \text{ e } S_{i, c} = S_{i-1, c-w_i} ∪ \{i\}$$
	Siccome **non possiamo sapere a priori se l’oggetto i appartenga o meno alla soluzione**, consideriamo entrambe le soluzioni e scegliamo quella di valore massimo. Dunque, se wi ≤ c, possiamo scrivere: $$OPT_{i,c} = max(OPT_{i−1,c}, OPT_{i−1,c−w_i} + v_i)$$
	e $$ S_{i, c} = \begin {cases} S_{i-1, c} & OPT_{i−1,c} ≥ OPT_{i−1,c−w_i} + v_i \\ S_{i-1, c-w_i} ∪ \{i\} & altrimenti\end {cases}$$
- risulta quindi: 
$$OPT_{i,c} = \begin {cases} OPT_{i−1,c} & w_i>c \\ max(OPT_{i−1,c}, OPT_{i−1,c−w_i} + v_i) & altrimenti\end {cases}$$
e
$$
OPT_{i,c} = 
\begin {cases} 
S_{i−1,c} & w_i>c \\ 
\begin {cases} 
S_{i−1,c} & OPT_{i−1,c} ≥ OPT_{i−1,c−w_i} + v_i \\
S_{i−1,c-w_i} ∪ \{i\} & altrimenti
\end {cases}
& altrimenti
\end {cases}
$$

---
## Algoritmo DP

1. uso una **matrice** $OPT[0...n][0...C]$ per salvare tutti i `sottoproblemi` $OPT_{i, c}$
2. uso una **matrice** $S[0...n][0...C]$ per salvare i sottoinsiemi finali di ogni sottoproblema 

``` Pseudocodice TI:"KP" "FOLD"
void KP(n, C)
	for i from 0 to n do 
		OPT[i, 0] = 0
		S[i, 0] = ∅
	for c from 0 to C do
		OPT[0, c] = 0
		S[0, c] = ∅
	for i from 1 to n do 
		for c from 1 to C do 
			if w[i] > c then 
				OPT[i, c] = OPT[i-1, c]
				S[i, c] = S[i-1, c]
			else
				V1 = OPT[i-1, c]
				V2 = OPT[i−1, c−w[i]] + v[i]
				OPT[i, c] = MAX(V1, V2)
				if V1 > V2 then
					S[i, c] = S[i-1, c]
				else
					S[i, c] = S[i-1, c-w[i]] ∪ i
	return (OPT[n, C], S[n, C])
```


> [!Summary]
> - ***Complessità***: $O(nC)$
> - ***Memoria***: $O(nC + n^2C)$

![[Pasted image 20231020172137.png]]

---

## Ricostruzione delle operazioni

- se non dovessi usare la matrice $S[0...n][0...C]$

``` Pseudocodice TI:"ricostruisci_KP" "FOLD"
void ricostruisci_KP(OPT, i, c)
	if i > 0 and c > o then
		if w[i] > c then
			ricostruisci_KP(OPT, i-1, c)
		else
			if OPT[i, c] == OPT[i-1, c] then
				ricostruisci_KP(OPT, i-1, c)
			else
				ricostruisci_KP(OPT, i-1, c-w[i])
				print i
``` 

![[Pasted image 20231020173943.png]]