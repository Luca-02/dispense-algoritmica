
>[!Premise]
>Introduciamo la funzione $f, f : Σ^∗ → N$, così definita: 
>$∀S ∈ Σ^∗ , f(S) =$ numero minimo di caratteri da aggiungere per rendere S palindroma.

*Date tre sequenze, definite su un alfabeto $Σ$, $X = ⟨x_1, . . . , x_m⟩$ di lunghezza $m$, $Y = ⟨y_1, . . . , y_n⟩$ di lunghezza $n$ e $W = ⟨w_1, . . . , w_{m+n}⟩$ di lunghezza $m + n$, stabilire se $W$ è un interleaving di $X$ e $Y$ , ovvero se $X$ e $Y$ si possono trovare come due sottosequenze disgiunte in $W$.*

>[!Example]
>Ad esempio, date $X = ⟨C, I, A, O⟩$ e $Y = ⟨M, A, M, M, A⟩$, possiamo dire che $W = ⟨C, I, M, A, A, M, M, A, O⟩$ è interleaving di $X$ e $Y$ .

---
## Sottoproblemi

*Date tre sequenze $X$, $Y$ e $W$, rispettivamente di lunghezza $m$, $n$ e $m + n$, si determini se $W_{i+j}$ è interleaving di $X_i$ e $Y_j$.*

- Considerato il sottoproblema di dimensione $(i, j)$, la `variabile` ad esso associata è $s_{i,j}$ ed è così definita:
	- $s_{i,j}$ = $True$ se $W_{i+j}$ è interleaving di $X_i$ e $Y_j$, $False$ altrimenti

**Numero di sottoproblemi**: $(m+1)(n+1)$
**Soluzione del problema**: $s_{m, n}$

---
## Sottostruttura ottima

Date $X=⟨x_1, x_2, …, x_{m-1}, x_m⟩$ e $Y=⟨y_1, y_2, …, y_{n-1}, y_n⟩$:

- $x_m = y_n \Rightarrow LCS(X_{m-1}, Y_{n-1}) + ⟨x_m⟩$
- $x_m \neq y_n \Rightarrow max(LCS(X_{m-1}, Y_{n}), LCS(X_{m}, Y_{n-1}))$ 

---
## Equazioni di ricorrenza

Nella risoluzione di questo esercizio è più comodo procedere per casi in base ai prefissi di $X$, $Y$, $W$, senza da subito distinguere tra essi quelli che fan parte del caso base e quelli che fan parte del passo ricorsivo.

#### Primo caso: $i = 0 ∨ j = 0$
Quando uno dei due prefissi considerati è la sequenza vuota.
- $i = 0 ∧ j = 0$: se **entrambi i prefissi sono la sequenza vuota**, allora $W_{i+j}$ è la sequenza vuota e di consguenza sarà interleaving di $X_i$ e $Y_j$$$s_{i,j} = True$$
- $i = 0 ∧ j > 0$: in questo caso bisogna considerare due situazioni diverse:
	- $w_j = y_j$ : se l’elemento $w_j$ è **uguale** all’elemento $y_j$ , allora $w_j$ è interleaving di $X_i$ e $Y_j$ solo se lo era anche $W_{i+j−1}$ $$s_{i,j} = s_{i,j−1}$$
#### <u>**Caso base**</u>: $i ≥ j$
- $i = j$: allora $S_{i,j}$ è composta da un solo carattere e quindi è palindroma, quindi $$m_{i,j} = 0$$
- $i > j$: allora $S_{i,j}$ è vuota e quindi è palindroma, quindi $$m_{i,j} = 0$$
- quindi $$m_{i,j} = 0 \quad\text{se } i\geq j$$
#### <u>**Passo ricorsivo**</u>: $i < j$
Il passo ricorsivo si ha per un qualunque sottoproblema di dimensione $(i, j)$ con $i < j$, ossia quando la sottostringa $S_{i,j}$ è composta da almeno due caratteri.
- $s_i = s_j$ : allora $S_{i,j}$ è palindroma se lo è anche $S_{i+1,j−1}$, quindi $$m_{i,j} = m_{i+1,j−1}$$
- $s_i \neq s_j$ : allora $S_{i,j}$ è palindroma se lo è anche $S_{i+1,j}$ o $S_{i,j−1}$, quindi $$m_{i,j} = min(m_{i+1,j} , m_{i,j−1}) + 1$$
- risulta quindi:
$$m_{i, j} = 
\begin {cases} 
0 & i ≥ j \\
m_{i+1,j−1} & i < j ∧ s_i = s_j \\
min(m_{i+1,j} , m_{i,j−1}) + 1 & i < j ∧ s_i \neq s_j
\end {cases}
$$

---
## Algoritmo DP

- uso una **matrice** $m[0...n][0...n]$ per salvare tutti i `sottoproblemi` $m_{i, j}$

``` Pseudocodice TI:"PAL" "FOLD"
def PAL(S) 
	for j from 1 to n do
		for i from j to n
			m[i, j] = 0
	for i from n-1 to 1 do
		for j from i + 1 to n do
			if s[i] = s[j] then
				m[i, j] = m[i+1, j-1]
			else
				M1 = m[i+1, j]
				M2 = m[i, j-1]
				m[i, j] = min(M1, M2)
	return m[1, n]
```

> [!Summary]
> - ***Complessità***: $O(n^2)$
> - ***Memoria***: $O(n^2)$

![[Pasted image 20231116153032.png]]