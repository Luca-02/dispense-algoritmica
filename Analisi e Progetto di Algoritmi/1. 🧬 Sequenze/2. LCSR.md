>[!Premise]
>Sia C un insieme di colori. Gli elementi della sequenza considerata in questo esercizio sono numeri naturali colorati. La funzione di colorazione è definita nel seguente modo: 
>$$φ : N → C$$
>Per esempio, data la funzione:
>$$φ(x) = \begin {cases} rosso & \text{se } x < 5 \\blu & \text{se } 5 <= x <= 10 \\ verde & \text{se } x > 10 \\ \end {cases}$$
>la sequenza  
>$$X = <2, 4, 7, 6, 11, 3, 21, 14, 1>$$
>sarà colorata nel seguente modo: 
>$$<r, r, b, b, g, r, g, g, r>$$
>

*Date due sequenze $X$ e $Y$ , rispettivamente di $m$ e $n$ numeri interi, e un naturale $R$, stabilire se tutte le più lunghe sottosequenze comuni a $X$ e $Y$ contengono al più $R$ elementi colorati di $rosso$.

--- 
## Sottoproblemi

*Date due sequenze $X$ e $Y$, rispettivamente di $m$ ed $n$ numeri interi, e un naturale $r$, stabilire se tutte le più lunghe sottosequenze comuni a $X_i$ e $Y_j$ contengono al più $r$ elementi colorati di $rosso$.

- Considerato il sottoproblema di dimensione $(i, j, r)$, la `variabile` ad esso associata è $c_{i,j,r}$ ed è così definita:
	- $c_{i,j,r} = true$ se e solo se tutte le più lunghe sottosequenze comuni a $X_i$ e $Y_j$ **contengono al più** $r$ elementi colorati di $rosso$, `altrimenti` $false$

**Numero di sottoproblemi**: $(m+1)(n+1)(R+1)$
**Soluzione del problema**: $(m, n, R)$

---

## Equazioni di ricorrenza

<u>**Caso base**</u>:
1. $(i, j, r)$ con $i = 0 \lor j = 0$ : 
	questo caso base si verifica quando uno dei due prefissi considerati è la sequenza vuota;
	dato che si richiede che tutte le più lunghe sottosequenze comuni contengano al più $r$ elementi colorati di $rosso$, l’unica più lunga sottosequenza comune fra la sequenza vuota e una qualsiasi sequenza è la sequenza vuota:


$$c_{i, j, r} = 
\begin {cases} 
true & \text{se } i = 0 ∨ j = 0 \\
false & \text{se } i > 0 \land j > 0 \land r = 0 \land x_i = y_j \land φ(x_i) = φ(y_j) = rosso
\end {cases}
$$
- **Passo ricorsivo**: $(i, j)$ con $i$ > 0 e $j$ > 0

---

## Algoritmo ricorsivo

``` Pseudocodice TI:"" "FOLD"

```

---

## Algoritmo DP

1. Costruzione di una matrice D[0…m, 0…n]
2. Riempimento di D in modo tale che D[i, j] = di,j per 0 ≤ i ≤ m e 0 ≤ j ≤ n
3. Soluzione di PR à D[m, n]

``` Pseudocodice TI:"" "FOLD"

```
