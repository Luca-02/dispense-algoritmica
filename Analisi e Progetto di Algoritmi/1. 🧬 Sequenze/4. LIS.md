*Data una sequenza $X$ di m numeri interi, si determini la lunghezza di una tra le più lunghe sottosequenze crescenti di $X$.

---
## Sottoproblemi

*Data una sequenza $X$ di m numeri interi, si determini la lunghezza di una tra le più lunghe sottosequenze crescenti di $X_i$.

- Considerato il sottoproblema di dimensione $(i)$, la `variabile` ad esso associata è $c_i$ ed è così definita:
	- $c_{i}$ = $|LIS(X_i)|$
	- $c_{i}$ = lunghezza di una tra le più lunghe sottosequenze crescenti di $X_i$

**Numero di sottoproblemi**: $m$

Purtroppo, però, il problema così definito **non è risolvibile**! `Ci manca informazioni`.
Risulta necessario **introdurre un problema ausiliario**, nel quale introdurre l’informazione mancante necessaria.

---
## Problema ausiliario

*Data una sequenza $X$ di m numeri interi, si determini la lunghezza di una tra le più lunghe sottosequenze crescenti di $X_i$ e che termina con $x_m$.

- Considerato il sottoproblema di dimensione $(i)$, la `variabile` ad esso associata è $c_i$ ed è così definita:
	- $c_{i}$ = $|LIS_V(X_i)|$
	- $c_{i}$ = lunghezza di una tra le più lunghe sottosequenze crescenti di $X_i$ e che termina con $x_i$

**Numero di sottoproblemi**: $m$
**Soluzione del problema**: $max({c_i | 1 \leq i \leq m})$

Purtroppo, però, il problema così definito **non è risolvibile**: `ci manca informazioni`.
Risulta necessario **introdurre un problema ausiliario**, nel quale introdurre l’informazione mancante necessaria.

---

## Equazioni di ricorrenza
#### <u>**Caso base**</u>: $(i)$ con $i \leq 1$
- Il caso base si ha per un qualunque sottoproblema di dimensione $(i)$ con $i = 0 \lor i =1$, ossia quando il prefisso considerato è la `sequenza vuota oppure` è una sequenza composta da un `singolo elemento`.
	Il caso base $i = 0$, comunque, risulta non necessario in quanto è possibile utilizzare, come caso base, solamente il caso $i = 1$:
$$ c_{i} = 1 \quad\text{se } i = 1$$

#### <u>**Passo ricorsivo**</u>: $(i)$ con $i > 1$
- Il passo ricorsivo si ha per un qualunque sottoproblema di dimensione (i) con i > 1, ossia quando si considera un prefisso della sequenza X in input di almeno due elementi.

	Se prendiamo la più lunga sottosequenza crescente alla quale **possiamo attaccare** $x_i$ e accodiamo ad essa $x_i$ , otteniamo la `più lunga sottosequenza crescente` di $X_i$ che termina con $x_i$ . 
	La lunghezza di tale sottosequenza sarà uguale alla lunghezza della sottosequenza crescente alla quale abbiamo accodato $x_i$ **aumentata** di $1$:
	$$c_i = 1 + max({c_h | 1 \leq h < i \land x_h < x_i})$$
	assumiamo per definizione che $max(∅) = 0$.

---
## Algoritmo ricorsivo

``` Pseudocodice TI:"LIS_ricorsiva" "FOLD"
int LIS_ricorsiva(i)
	if i = 1 then
		return 1
	else
		max = 0
		for h from 1 to i-1 do
			if x[h] < x[i] then
				S = LIS_ricorsiva(h)
				if S > max then
					max = S
		return max + 1
```

---
## Algoritmo DP

- uso una **matrice** $c[0...m][0...n]$ per salvare tutti i `sottoproblemi` $c_{i, j}$
- `[facoltativa]` uso una matrice $b[1...m][1...n]$ per salvare le operazioni per il **backtracking**

``` Pseudocodice TI:"LCS" "FOLD"
int LCS(X, Y) 
	m = length[X]
	n = length[Y]
	for i from 0 to m do
		c[i, 0] = 0
	for j from 0 to n do
		c[0, j] = 0
	for i from 1 to n do
		for j from 1 to n do
			if x[i] = y[j] then
				c[i, j] = c[i-1, j-1] + 1
				b[i, j] = "↖"
			else
				if (c[i-1, j] >= c[i, j-1])
					c[i, j] = c[i-1, j]
					b[i, j] = "↑"
				else 
					c[i, j] = c[i, j-1]
					b[i, j] = "←"
	return c and b
```

>[!Note]
>b è una lista di backtracking usata per ricostruire la LCS.

> [!Summary]
> - ***Complessità***: $O(mn)$
> - ***Memoria***: $O(mn)$

![[Pasted image 20231010003502.png]]


---
## Ricostruzione delle operazioni

##### Versione iterativa

``` Pseudocodice TI:"ricostruisci_LCS" "FOLD"
List ricostruisci_LCS(c, m, n)
	i = m
	j = n
	LCS = empty list
	while i > 0 and j > 0 do
		if x[i] = y[j] then
			append x[i] to LCS
			i--
			j--
		 else
			 if c[i, j] = c[i-1, j] then
				 i--
			 else
				 j--
	 return LCS
```

> [!Summary]
> - ***Complessità***: $O(m + n)$
> - ***Memoria***: $O(mn)$


![[Pasted image 20231010005928.png]]

##### Versione ricorsiva

``` Pseudocodice TI:"ricostruisci_LCS" "FOLD"
void ricostruisci_LCS(c, i, j)
	if i > 0 and j > 0 then
		if x[i] = y[j] then
			ricostruisci_LCS(c, i-1, j-1)
			print x[i]
		else
			if c[i, j] = c[i - 1, j] then
				ricostruisci_LCS(c, i-1, j)
			else
				ricostruisci_LCS(c, i, j-1)
```
