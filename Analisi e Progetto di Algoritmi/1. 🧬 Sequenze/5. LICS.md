*Date due sequenze $X$ e $Y$ , rispettivamente di m e n numeri interi, si determini **UNA** tra le più lunghe sottosequenze crescenti comuni a $X$ e $Y$.

---
## Sottoproblemi

*Date due sequenze $X$ e $Y$ , rispettivamente di $m$ ed $n$ numeri interi, si determini la lunghezza di una tra le più lunghe sottosequenze crescenti comuni al prefisso $X_i$ e al prefisso $Y_j$.

- Considerato il sottoproblema di dimensione $(i, j)$, la `variabile` ad esso associata è $c_{i, j}$ ed è così definita:
	- $c_{i, j}$ = $|LICS(X_i, Y_j)|$
	- $c_{i, j}$ = lunghezza di una tra le più lunghe sottosequenze crescenti comuni a $X_i$ e $Y_j$

**Numero di sottoproblemi**: $(m+1)(n+1)$

Purtroppo, però, il problema così definito **non è risolvibile**: `ci manca informazioni`.

**Non c’è alcun modo** per poter comprendere se gli elementi $x_i$ e $y_j$ , nel caso fossero uguali, **possano essere accodati** alle sottosequenze crescenti relative ai sottoproblemi di dimensione minore a $(i, j)$: non sappiamo con quale elemento termini ognuna di queste sottosequenze ma ne conosciamo solo la lunghezza.

Risulta necessario **introdurre un problema ausiliario**, nel quale introdurre l’informazione mancante necessaria.

---
## Problema ausiliario (sottoproblema vincolato)

*Date due sequenze $X$ e $Y$ , rispettivamente di $m$ ed $n$ numeri interi, si determini la lunghezza di una tra le più lunghe sottosequenze crescenti comuni a $X_i$ e a $Y_j$ e che termina con $x_i$ e $y_j$ (se questi coincidono).

- Considerato il sottoproblema di dimensione $(i, j)$, la `variabile` ad esso associata è $c_i$ ed è così definita:
	- $c_{i, j}$ = $|LICS_V(X_i, Y_j)|$
	- $c_{i}$ = lunghezza di una tra le più lunghe sottosequenze crescenti comuni a $X_i$ e $Y_j$ e che termina con $x_i$ e $y_j$ (se questi coincidono)

**Numero di sottoproblemi**: $(m+1)(n+1)$
**Soluzione del problema**: $max({c_{i, j} | 1 \leq i \leq m \land 1 \leq j \leq n})$

---
## Sottostruttura ottima



---
## Equazioni di ricorrenza
#### <u>**Caso base**</u>: $(i, j)$ con $i > 0 \land j > 0$ tali che $x_i \neq y_j$
- Fanno parte del caso base tutte le coppie $(i, j)$ con $i = 0 \lor j = 0$ ma il caso base si ha anche per un qualunque sottoproblema di dimensione $(i, j)$ tale che $x_i \neq y_j$, ossia quando i due prefissi $X_i$ e $Y_j$ considerati **terminano con due elementi diversi**:
$$ c_{i, j} = 0 \quad\text{se } i > 0 \land j > 0 \land x_i \neq y_j$$

#### <u>**Passo ricorsivo**</u>: $(i, j)$ con $i > 0 \land j > 0$ tali che $x_i = y_j$
- Il passo ricorsivo si ha per un qualunque sottoproblema di dimensione $(i, j)$ tale che $x_i = y_j$ , ossia quando i due prefissi $X_i$ e $Y_j$ considerati terminano con lo stesso elemento.

	Se prendiamo la più lunga sottosequenza crescente alla quale **possiamo attaccare** $x_i$ e accodiamo ad essa $x_i$ , otteniamo la `più lunga sottosequenza crescente` di $X_i$ che termina con $x_i$ . 
	La lunghezza di tale sottosequenza sarà uguale alla lunghezza della sottosequenza crescente alla quale abbiamo accodato $x_i$ **aumentata** di $1$:
	$$c_i = max({c_h | 1 \leq h < i \land x_h < x_i}) + 1$$
	assumiamo per definizione che $max(∅) = 0$.

---
## Algoritmo ricorsivo

``` Pseudocodice TI:"LIS_ricorsiva" "FOLD"
int LIS_ricorsiva(i)
	if i = 1 then
		return 1
	else
		max = 0
		for h from 1 to i-1 do
			if x[h] < x[i] then
				S = LIS_ricorsiva(h)
				if S > max then
					max = S
		return max + 1
```

---
## Algoritmo DP

- uso un **array** $c[1...m]$ per salvare tutti i `sottoproblemi` $c_i$
- `[facoltativa]` uso un **array** $b[1...m]$ per salvare gli indici della $LIS_V$ che precede l'indice $i-esimo$ per il **backtracking**

``` Pseudocodice TI:"LIS" "FOLD"
int LIS(X, Y) 
	c[1] = 1
	b[1] = 0
	max = c[1]
	for i from 2 to m do
		temp = 0
		b[i] = 0
		for h from 1 to i-1 do
			if x[h] < x[i] and c[h] > temp then
				temp = c[h]
				b[i] = h
		c[i] = temp + 1
		if c[i] > max then
			max = c[i]
	return max
```

> [!Summary]
> - ***Complessità***: $O(m^2)$
> - ***Memoria***: $O(m)$


![[Pasted image 20231012165143.png]]

---
## Ricostruzione delle operazioni

##### Versione ricorsiva

``` Pseudocodice TI:"ricostruisci_LIS_V" "FOLD"
void ricostruisci_LIS_V(b, i)
	if b[i] != 0 then
		ricostruisci_LIS_V(b, b[i])
	print x[i]
```

>[!Note]
>Chiamando la procedura per $i_{max}$ (posizione della cella di $c$ che contiene il valore massimo) si ottiene la stampa di una soluzione ottimale di $LIS(X)$

> [!Summary]
> - ***Complessità***: $O(m)$
> - ***Memoria***: $O(m)$
