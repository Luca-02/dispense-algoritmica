Definiamo $MST$ il **sottoinsieme ottimo** di un matroide grafico $M_G$, definiamo $M_G = (S, F)$, per $G=(V,E,W)$ *non orientato e connesso*, con:
- $S$: l’insieme $E$ degli archi di $G$.
- $F$: tutti i sottoinsiemi aciclici di $S$.

pesato con $W : S → R^+$ tale che $W(s)$ è il peso dell’arco $s$.

Un sottoinsieme ottimo di $M_G$ pesato con $W$ è il *Minimum Spanning Tree* ($MST$), quindi uno *Spanning Tree* ($ST$) di peso **minimo**.

---

## Algoritmo

Modifico l'*Algoritmo Greedy Standard per Problema di Minimo* standard stando al fatto che $e_i = (u, v)$ è un **arco sicuro** se è un arco di peso minimo che connette un vertice di una componente connessa C, del grafo, con un vertice che non è in C.

``` Pseudocodice TI:"KRUSKAL-MST" "FOLD"
def KRUSKAL-MST(G=(V, E), W) 
	A = ∅
	E = ⟨e[1], e[2], …, e[n]⟩ // ordinati per peso crescente
	
	for i from 1 to n do
		(u,v) = e[i]
		if u e v ∉ stessa componente di G_A = (V, A) then
			A = {(u,v)} ∪ A
		
	return A
```

>[!Important]
>Per l'esempio grafico vedere le slide *Problema del Minimum Spanning Tree (MST)* alla slide 115.

Ora bisogna integrare delle strutture dati dette **insiemi disgiunti** per gestire le componenti connesse del grafo dove:
- **MAKE_SET(v)**: Questa operazione viene utilizzata per creare un insieme disgiunto contenente un singolo elemento $v$. In altre parole, ogni vertice del grafo inizialmente appartiene a un insieme disgiunto separato. Questo insieme rappresenta un singolo nodo nell'albero di copertura minimo.

Ad esempio, se hai un grafo con i vertici A, B, C, e D, l'inizializzazione potrebbe essere:

``` Pseudocodice TI:"KRUSKAL-MST" "FOLD"
def KRUSKAL-MST(G=(V, E), W) 
	A = ∅
	E = ⟨e[1], e[2], …, e[n]⟩ // ordinati per peso crescente
	foreach v ∈ V do 
		MAKE_SET(v)
	
	for i from 1 to n do
		(u,v) = e[i]
		if FIND_SET(u) ≠ FIND_SET(v) then
			A = {(u,v)} ∪ A
			UNION(u,v)
	return A
```