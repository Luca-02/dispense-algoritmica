Sia $C$ una componente connessa del grafo, l'idea dell'algoritmo è:
1. Sceglie un vertice arbitrario $r$, la componente connessa $C$ iniziale è composta dal solo vertice $r$ $$V_C = \{r\}$$
2. Individuo l’arco di peso minimo che parte da r e raggiunge un altro vertice $v_1$, il vertice $v_1$ entra a far parte di $C$ $$V_C = \{r, v_1\}$$
3. Individuo l’arco di peso minimo che connette un vertice in $C$ a un vertice $v_2 \not∈ C$, il vertice $v_2$ entra a far parte di $C$ $$V_C = \{r, v_1, v_2\}$$
4. Eccetera...
5. L’algoritmo termina quando $C$ contiene tutti i vertici del $MST$

#### Proprietà dell'Algoritmo

- Il sottoinsieme $A$ degli archi di $MST$ aggiunti, stanno tutti nella componente connessa $C$. La foresta $G_A = (V,A)$ è composta da: 
	- $C = (V_C, A)$
	- $|V-V_C|$ componenti di vertici singoli
- Il taglio $(V_C, V-V_C)$ rispetta l’insieme $A$
- L’arco sicuro è l’arco di peso minimo che connette un vertice in $C$ con un vertice non in $C$

>[!Important]
>Per l'esempio grafico vedere le slide *Problema del Minimum Spanning Tree (MST)* alla slide $186$. 

Ogni vertice $v$ possiederà due valori:
- $v.key$ che rappresenta il **peso dell’arco** che lo unirà a $C$ 
- $v.π$ che indica il nodo di $C$ a cui si è collegato, quindi il **predecessore**

L’algoritmo vero e proprio funziona grazie ad una coda $Q$, che permette l’estrazione del vertice con il minimo valore del campo $key$, che contiene al suo interno tutti i vertici del grafo e ad ogni passo *"perde"* l’ultimo elemento in quanto esso entrerà a far parte di $C$.

>[!Important]
>Per l'esempio grafico vedere le slide *Problema del Minimum Spanning Tree (MST)* alla slide $224$.

