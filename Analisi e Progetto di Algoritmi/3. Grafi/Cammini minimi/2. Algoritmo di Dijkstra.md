## Algoritmo di Dijkstra

A partire dai valori:
- $v.d = ∞$ per ogni vertice $v \not= s$
- $v.p = NIL$ per ogni vertice $v$
- $s.d = 0$ per la sorgente $s$

Viene eseguito per ogni arco $(u,v)$ del grafo un solo passo di **rilassamento** per ottenere alla fine dell’esecuzione:
- $v.d = δ(s,v)$ peso del cammino minimo da $s$ a $v$
- $v.\pi = u$ predecessore di $v$ nel cammino minimo da $s$ a $v$

Una coda $Q$ di *min-priority*, dove verrà estratto sempre il vertice $v$ con il **minimo** valore di $v.d$, contiene all’inizio tutti i vertici del grafo e **ad ogni passo** si avrà che:
- $Q$ conterrà tutti i vertici $v$ per i quali il campo $v.d$ non ha raggiunto il valore $δ(s, v)$, ovvero il **minimo**
- Se un vertice $u$ viene estratto da $Q$, il suo campo $u.d$ sarà uguale a $δ(s, u)$
- Per ogni arco uscente da $u$ *(figlio di $u$)*, si dovrà svolgere il **rilassamento**
- l’algoritmo termina quando $Q$ è vuota

Alla fine, tramite i valori del campo dei predecessori si ricostruisce il cammino minimo dalla sorgente $s$ a un determinato vertice $v$.

>[!Important]
>Per l'esempio grafico vedere le slide *Cammini minimi da sorgente unica (Algoritmo di Dijkstra)* alla slide $38$. 

---

## Prova di correttezza

Sia $⟨v_1 = s, v_2, . . . , v_n⟩$ la sequenza di vertici estratti da $Q$ in un’esecuzione. Quando il vertice $v_k$ viene estratto, allora $$v_k.d = δ(s, v_k)$$quindi sarà *sicuramente* il **cammino minimo** da $s$ a $v_k$.

