Definiamo $MST$ il **sottoinsieme ottimo** di un matroide grafico $M_G$, definiamo $M_G = (S, F)$, per $G=(V,E,W)$ *non orientato e connesso*, con:
- $S$: l‚Äôinsieme $E$ degli archi di $G$.
- $F$: tutti i sottoinsiemi aciclici di $S$.

pesato con $W : S ‚Üí R^+$ tale che $W(s)$ √® il peso dell‚Äôarco $s$.

Un sottoinsieme ottimo di $M_G$ di peso **minimo** pesato con $W$ √® il *Minimum Spanning Tree* ($MST$), quindi uno *Spanning Tree* ($ST$) di peso minimo.

---
## Algoritmo

Modifico l'*Algoritmo Greedy Standard per Problema di Minimo* stando al fatto che $e_i = (u, v)$ √® un **arco sicuro** se √® un arco di peso minimo che connette un vertice di una componente connessa $C$, del grafo, con un vertice che non √® in $C$.

``` Pseudocodice TI:"KRUSKAL-MST" "FOLD"
def KRUSKAL-MST(G=(V, E), W) 
	A = ‚àÖ
	E = ‚ü®e[1], e[2], ‚Ä¶, e[n]‚ü© // ordinati per peso crescente
	
	for i from 1 to n do
		(u,v) = e[i]
		if u e v ‚àâ stessa componente di G_A = (V, A) then
			A = {(u,v)} ‚à™ A
		
	return A
```

>[!Important]
>Per l'esempio grafico vedere le slide *Problema del Minimum Spanning Tree (MST)* dalla slide $115$.

Ora bisogna integrare delle strutture dati dette **insiemi disgiunti** per gestire le componenti connesse del grafo dove:
- $MAKE\_SET(v)$: Questa operazione viene utilizzata per creare un insieme disgiunto contenente un singolo elemento $v$. In altre parole, ogni vertice del grafo inizialmente appartiene a un insieme disgiunto separato. Questo insieme rappresenta un singolo nodo nell'albero di copertura minimo. Ad esempio, se hai un grafo con i vertici $A$, $B$, $C$, e $D$, l'inizializzazione potrebbe essere:
	```
	MAKE_SET(A) 
	MAKE_SET(B) 
	MAKE_SET(C) 
	MAKE_SET(D)
	```
	Alla fine di queste operazioni, avr√≤ quattro insiemi disgiunti, ognuno contenente un singolo vertice.
- $FIND\_SET(v)$: Questa operazione viene utilizzata per trovare l'insieme disgiunto a cui appartiene un elemento $v$. In sostanza, determina il rappresentante dell'insieme a cui appartiene il vertice $v$. Questa operazione √® fondamentale per verificare se l'aggiunta di un arco crea un ciclo. Ad esempio, se esegui $FIND\_SET(B)$ e restituisce l'insieme $\{B\}$, significa che $B$ √® attualmente rappresentato dall'insieme che contiene solo $B$.
- $UNION(u, v)$: Questa operazione viene utilizzata per unire due insiemi disgiunti, ovvero gli insiemi a cui appartengono i vertici $u$ e $v$. Questo rappresenta l'unione di due sottoalberi nell'albero di copertura minimo quando viene aggiunto un arco. Ad esempio, se esegui $UNION(A, B)$, unisci gli insiemi che contengono $A$ e $B$ in un unico insieme pi√π grande. L'insieme risultante potrebbe diventare ${A, B}$.

In sintesi, $MAKE\_SET$ √® utilizzato per inizializzare gli insiemi disgiunti, $FIND\_SET$ √® utilizzato per trovare l'insieme a cui appartiene un elemento, e $UNION$ √® utilizzato per unire due insiemi disgiunti quando vengono collegati da un arco. Queste operazioni sono **fondamentali** nell'*algoritmo di Kruskal* **per garantire che l'aggiunta di archi non crei cicli nell'albero di copertura minimo**.

``` Pseudocodice TI:"KRUSKAL-MST" "FOLD"
def KRUSKAL-MST(G=(V, E), W) 
	A = ‚àÖ
	E = ‚ü®e[1], e[2], ‚Ä¶, e[n]‚ü© // ordinati per peso crescente
	foreach v ‚àà V do 
		MAKE_SET(v)
	
	for i from 1 to n do
		(u,v) = e[i]
		if FIND_SET(u) ‚â† FIND_SET(v) then
			A = {(u,v)} ‚à™ A
			UNION(u,v)
	return A
```

> [!Summary]
> - Ordinamento: $ùëÇ(|ùê∏| ùëôùëúùëî|ùê∏|)$ perch√® ordiniamo |E| elementi
>- ***Complessit√†***: $O(|E| \log(|E|))$
>Per vedere meglio la complessit√† vedere le slide *Problema del Minimum Spanning Tree (MST)* alla slide $163$.
