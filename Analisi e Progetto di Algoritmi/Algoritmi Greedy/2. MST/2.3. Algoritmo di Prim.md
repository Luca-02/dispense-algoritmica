Sia $C$ una componente connessa del grafo, l'idea dell'algoritmo Ã¨:
1. Sceglie un vertice arbitrario $r$, la componente connessa $C$ iniziale Ã¨ composta dal solo vertice $r$ $$V_C = \{r\}$$
2. Individuo lâ€™arco di peso minimo che parte da $r$ e raggiunge un altro vertice $v_1$, il vertice $v_1$ entra a far parte di $C$ $$V_C = \{r, v_1\}$$
3. Individuo lâ€™arco di peso minimo che connette un vertice in $C$ a un vertice $v_2 \notâˆˆ C$, il vertice $v_2$ entra a far parte di $C$ $$V_C = \{r, v_1, v_2\}$$
4. Eccetera...
5. Lâ€™algoritmo termina quando $C$ contiene tutti i vertici del $MST$

#### ProprietÃ  dell'Algoritmo

- Il sottoinsieme $A$ degli archi di $MST$ aggiunti, stanno tutti nella componente connessa $C$. La foresta $G_A = (V,A)$ Ã¨ composta da: 
	- $C = (V_C, A)$
	- $|V-V_C|$ componenti di vertici singoli
- Il taglio $(V_C, V-V_C)$ rispetta lâ€™insieme $A$
- Lâ€™arco sicuro Ã¨ lâ€™arco di peso minimo che connette un vertice in $C$ con un vertice non in $C$

---
## Algoritmo

Viene mantenuta una coda $Q$ di *min-priority* che allâ€™inizio contiene tutti i vertici del grafo dove ad ogni passo:
- contiene i vertici che **non** appartengono ancora alla componente connessa $C$
- permette di estrarre il vertice $v$ tale che $(u,v)$ Ã¨ lâ€™arco di **peso minimo** che collega un vertice $u$ in $C$ con un vertice non ancora in $C$

Ogni vertice $v$ ha due valori:
- $v.key$ che rappresenta il **peso dellâ€™arco** che lo unirÃ  a $C$ 
- $v.Ï€$ che indica il nodo di $C$ a cui si Ã¨ collegato, quindi il **predecessore**

#### Funzionamento
Allâ€™inizio si sceglie un vertice di partenza $r$ e per ogni vertice $V$ del grafo.
- $v.key = âˆž$ e $r.key = 0$
- $v.Ï€ = NIL$

Aggiungo inizialmente tutti i vertici del grafo nella coda $Q$ e ad ogni passo:
1. viene estratto da $Q$ il vertice $u$ con il minor valore del campo $key$:
	- lâ€™arco $(u.Ï€, u)$ Ã¨ un nuovo arco di $MST$
	- $u$ Ã¨ un nuovo vertice che si aggiunge alla componente $C$

2. per ogni vertice $v$ adiacente a $u$, se $v$ Ã¨ in $Q$ e il peso $W(u, v)$ Ã¨ inferiore a $v.key$, vengono aggiornati:
	- $v.key$ al valore $W(u,v)$
	- $v.Ï€$ al valore $u$

L'algoritmo termina quando $Q$ Ã¨ vuota e gli archi dell'$MST$ Ã¨ dato da:
$$T = \{(v.Ï€, v) | v âˆˆ V, v â‰  r\}$$

>[!Important]
>Per l'esempio grafico vedere le slide *Problema del Minimum Spanning Tree (MST)* dalla slide $186$ e $224$. 

``` Pseudocodice TI:"PRIM-MST" "FOLD"
def PRIM-MST(G = (V, E), W, r) // tale che r âˆˆ V
	for v âˆˆ V do
		v.key = âˆž
		v.Ï€ = NIL
	r.key = 0
	
	Aggiungi tutti i vertici di V alla coda Q di min-priority

	while Q â‰  âˆ… do
		u = estrai vertice un da Q con valore key minimo
		for v âˆˆ adj(u) do
			if v âˆˆ Q and W(u, v) < v.key then
				v.key = W(u, v)
				v.Ï€ = u
```

> [!Summary]
> - Inizializzazione + Inserimento vertici in coda: ð‘‚(|ð‘‰|) poichÃ¨ inizializziamo ed inseriamo tutti i vertici una volta 
> - While: ð‘‚(|ð‘‰|) poichÃ© ogni vertice viene estratto dalla coda esattamente una volta. 
> - Estrai vertice: ð‘‚(ð‘™ð‘œð‘”|ð‘‰|) per la necessitÃ  di mantenere la struttura di heap e riordinare gli elementi dopo l'estrazione 
>- Foreach: ð‘‚(|ð¸|) perchÃ¨ dobbiamo scorrere tutta la lista di adiacenza
>
>Quindi la complessitÃ  nel caso peggiore Ã¨:
>- ***ComplessitÃ ***: $O(|E| \log(|E|))$
>Per vedere meglio la complessitÃ  vedere le slide *Problema del Minimum Spanning Tree (MST)* dalla slide $337$.