Date due sequenze $X$ e $Y$ , rispettivamente di $m$ ed $n$ numeri interi, si determini **UNA** tra le `più lunghe sottosequenze comuni` a $X$ e $Y$.

---
## Sottoproblemi

Date due sequenze $X$ e $Y$ , rispettivamente di $m$ ed $n$ numeri interi, si determini la lunghezza di una tra le più lunghe sottosequenze comuni al prefisso $X_i$ e al prefisso $Y_j$.

- Considerato il sottoproblema di dimensione $(i, j)$, la `variabile` ad esso associata è $c_{i,j}$ ed è così definita:
	- $c_{i,j}$ = $|LCS(X_i, Y_j)|$
	- $c_{i,j}$ = lunghezza di una tra le più lunghe sottosequenze comuni a $X_i$ e $Y_j$

- Numero di sottoproblemi: $(m+1)(n+1)$

##### Soluzione del problema: $c_{m, n}$

---

## Equazioni di ricorrenza
- **Caso base**: $(i, j)$ con $i = 0 ∨ j = 0$
$$ c_{i,j} = 0 \quad\text{se } i = 0 \lor j = 0 $$
- **Passo ricorsivo**: $(i, j)$ con $i$ > 0 e $j$ > 0
$$c_{i, j} = 
\begin {cases} 
1 + c_{i-1,j-1} & \text{se } x_i = y_j \\
\max{c_{i,j-1}, c_{i-1,j}} & \text{se } x_i \neq y_j
\end {cases}
$$
---
## Algoritmo ricorsivo

``` Pseudocodice TI:"LCD_ricorsiva" "FOLD"
int LCS_ricorsiva(i, j)
	if i = 0 ⋁ j = 0 then 
		return 0 
	else 
		if x[i] = y[j] then 
			c[i, j] = LCDricorsiva(i - 1,j - 1) + 1 
			return c[i, j] 
		else 
			c[i - 1, j] = LCDricorsiva(i - 1, j) 
			c[i,j - 1] = LCDricorsiva(i, j - 1) 
			return max{c[i - 1, j], c[i, j - 1]}
```

---
## Algoritmo DP

``` Pseudocodice TI:"LCS" "FOLD"
int LCS(X, Y) 
	m = length[X]
	n = length[Y]
	for i from 0 to m do
		c[i, 0] = 0
	for j from 0 to n do
		c[0, j] = 0
	for i from 1 to n do
		for j from 1 to n do
			if x[i] = y[j] then
				c[i, j] = c[i - 1, j - 1] + 1
				b[i, j] = "↖"
			else
				if (c[i - 1, j] >= c[i, j - 1])
					c[i, j] = c[i - 1, j]
					b[i, j] = "↑"
				else 
					c[i, j] = c[i, j - 1]
					b[i, j] = "←"
	return c and b
```

>[!Note]
>b è una lista di backtracking usata per ricostruire la LCS.

---
## Ricostruzione delle operazioni

##### Versione iterativa

``` Pseudocodice TI:"ricostruisci_LCS" "FOLD"
List ricostruisci_LCS(C, m, n)
	i = m
	j = n
	LCS = empty list
	while i > 0 and j > 0 do
		if x[i] = y[j] then
			aggiungi x[i] in testa a LCS
			i--
			j--
		 else
			 if c[i, j] = c[i - 1, j] then
				 i--
			 else
				 j--
	 return LCS
```

##### Versione ricorsiva

``` Pseudocodice TI:"ricostruisci_LCS" "FOLD"
void ricostruisci_LCS(c, i, j)
	if i > 0 and j > 0 then
		if x[i] = y[j] then
			ricostruisci_LCS(c, i - 1, j - 1)
			print x[i]
		else
			if c[i, j] = c[i - 1, j] then
				ricostruisci_LCS(c, i - 1, j)
			else
				ricostruisci_LCS(c, i, j - 1)
```
