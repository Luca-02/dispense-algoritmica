Date due sequenze X e Y, trovare il `minimo insieme di operazioni di cancellazione, inserimento e sostituzione` (distanza di edit) che trasformano X in Y.

>[!Note]
Questo algoritmo è noto anche come distanza di Levenshtein.
>

---

## Sottoproblemi

Trovare la distanza di edit dei prefissi Xi e Yj.

- Considerato il sottoproblema di dimensione $(i, j)$, la `variabile` ad esso associata è $d_{i,j}$ ed è così definita:
	- $d_{i,j}$ = $|ED(X_i, Y_j)|$
	- $d_{i,j}$ = distanza di edit dei prefissi $X_i$ e $Y_j$

**Numero di sottoproblemi**: $(m+1)(n+1)$
**Soluzione del problema**: $d_{m, n}$

---

## Equazioni di ricorrenza

- **Caso base**: $(i, j)$ con $i = 0 \lor j = 0$
$$ d_{i,j} = 0 \quad\text{se } i = 0 \land j = 0 $$
$$ d_{i,j} = i \quad\text{se } i > 0 \land j = 0 $$
$$ d_{i,j} = j \quad\text{se } i = 0 \land j > 0 $$
- **Passo ricorsivo**: $(i, j)$ con $i$ > 0 e $j$ > 0
$$c_{i, j} = 
\begin {cases} 
d_{i,j} = d_{i-1, j-1} & \text{se } x_i = y_j \\
\min(di-1,j-1 + 1, di-1,j + 1, di,j-1 + 1) & \text{se } x_i \neq y_j
\end {cases}
$$

>[!Note]
>- $i > 0 \land j > 0 \land x_i = y_j$
>	$minOP(i, j) = minOP(i-1, j-1) \rightarrow d_{i,j} = d_{i-1,j-1}$
>- $i > 0 \land j > 0 \land x_i ≠ y_j$ tre possibilità per $minOP(i, j)$
>	- $sostituzione(x_i \rightarrow y_j) + minOP(i-1, j-1) \rightarrow 1 + d_{i-1,j-1}$
>	- $cancellazione(x_i) + minOP(i-1, j) \rightarrow 1 + d_{i-1,j}$
>	- $inserimento(y_j) + minOP(i, j-1) \rightarrow 1 + d_{i,j-1}$

---
## Algoritmo ricorsivo

``` Pseudocodice TI:"EDricorsiva" "FOLD"
int EDricorsiva(i, j)
	if i = 0 ⋁ j = 0 then
		return caso base
	else
		d[i - 1, j - 1] = EDricorsiva(i - 1, j - 1)
		if xi = yj then
			return d[i-1, j-1]
		else
			d[i - 1, j] = EDricorsiva(i - 1, j)
			d[i, j - 1] = EDricorsiva(i, j - 1)
			a = D[i - 1, j - 1] + 1 
			b = D[i - 1, j] + 1 
			c = D[i, j - 1] + 1
			return min(a, b, c)
```

---

## Algoritmo DP

``` Pseudocodice TI:"ED" "FOLD"
int ED(X, Y) 
	for i from 0 to m do 
		d[i, 0] = i 
	for j from 0 to n do
		d[0, j] = j 
	for i from 1 to m do
		for j from 1 to n do 
			if x[i] = y[j] then
				d[i, j] = d[i - 1, j - 1] 
			else 
				a = d[i - 1, j - 1] + 1
				b = d[i - 1, j] + 1
				c = d[i, j - 1] + 1
				d[i, j] = min(a, b, c) 
	return d[m, n]
```

---

## Ricostruzione delle operazioni

$di,j = d_{i-1,j-1} \rightarrow \text{"null operation"}$
$d_{i,j} = d_{i-1,j-1} + 1 \rightarrow substitution(x_i -> y_j)$
$d_{i,j} = d_{i-1,j} + 1 \rightarrow deletion(x_i)$
$d_{i,j} = d_{i,j-1} + 1 \rightarrow insertion(y_j) after x_i$
$d_{i,0} = i = (i-1) + 1 = d_{i-1,0} + 1 \rightarrow deletion(x_i)$
$d_{0,j} = j = (j-1) + 1 = d_{0,j-1} + 1 \rightarrow \text{insertion}(y_j) \text{ before } x_1$

##### Versione iterativa

``` Pseudocodice TI:"ricostruisci_minOP" "FOLD"
List ricostruisci_minOP(X, Y) 
	minOp = empty list
	i = m
	j = n 
	while i >= 0 or j >= 0 then 
		if from diagonal then 
			if xi != yj then 
				append substitution(x[i] -> y[j]) to minOP 
			i = i - 1 
			j = j - 1 
		else 
			if from left then 
				append deletion(x[i]) to minOP 
				i = i - 1 
			else 
				append insertion(y[j]) to minOP 
				j = j - 1
```

##### Versione ricorsiva

``` Pseudocodice TI:"Ricostruisci_minOP_ricorsiva" "FOLD"
void Ricostruisci_minOP_ricorsiva(D, i, j)
	if i >= 0 or j >= 0 then 
		if from diagonal then 
			if x[i] != y[j] then 
				append substitution(x[i] -> y[j]) to minOP 
			RicostruisciLCSricorsiva(D, i - 1, j - 1) 
		else 
			if from left then 
				append insertion(yj) to minOP 
				RicostruisciLCSricorsiva(D, i - 1, j) 
			else 
				append deletion(xi) to minOP 
				RicostruisciLCSricorsiva(D, i, j - 1)
```